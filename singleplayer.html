<!DOCTYPE HTML>
<html lang="es">
	<head>
		<title>minecraft web edition 0.0.0-B</title>
		
		<!-- Character encoding -->
		<meta content="text/html" charset="UTF-8">
		<!-- Favicon -->
		<link rel="icon" href="media/favicon.png">

		<!-- Stylesheet -->
		<link href="style/main.css" rel="stylesheet" type="text/css">
		
		<!-- Modules -->
		<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
		<script src="js/blocks.js" type="text/javascript"></script>
		<script src="js/perlin.js" type="text/javascript"></script>
		<script src="js/helpers.js" type="text/javascript"></script>
		<script src="js/items.js" type="text/javascript"></script>
		<script src="js/entities.js" type="text/javascript"></script>
		<script src="js/crafting.js" type="text/javascript"></script>
		<script src="js/worldManager.js" type="text/javascript"></script>
		<script src="js/world.js" type="text/javascript"></script>
		<script src="js/render.js" type="text/javascript"></script>
		<script src="js/physics.js" type="text/javascript"></script>
		<script src="js/player.js" type="text/javascript"></script>
		<script src="js/vr.js" type="text/javascript"></script>
		<style>
			body.mobile-mode #mobileControls {
				display: block !important;
				opacity: 1 !important;
				pointer-events: all;
				z-index: 99999;
			}
		</style>
	</head>
	
	<body oncontextmenu="return false">
		<!-- Loads the gui audio for buttons -->
		<audio id="clickSound" src="sounds/gui/Click_stereo.ogg.mp3" preload="auto"></audio>
		<!-- Render surface -->
		<canvas id="renderSurface"></canvas>
		
		<!-- VR Overlay Container - Para mostrar interfaz HTML en VR -->
		<div id="vrOverlayContainer" class="vr-overlay-container" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 100000; pointer-events: none;">
			<!-- Los menÃºs se mostrarÃ¡n aquÃ­ cuando estÃ© activo VR -->
		</div>

		<img id="cursor" class="cursor" src="media/gui/cursor.png" />
		<img id="crosshair" class="crosshair" src="media/gui/cursor.png" />

		<!-- VR Button -->
		<button id="vr-button" class="vr-button">
			ðŸŽ® Verificando VR...
		</button>

		<!-- FPS Display -->
		<div id="fpsDisplay" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Minecraftia; display: none;"></div>

		<!-- Debug Overlay (F3) -->
		<div id="debugOverlay" style="position: absolute; top: 10px; left: 10px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 1000;">
			<div id="debugInfo"></div>
		</div>
		
		
		<!-- Item Title Display (shows item name when switching hotbar slots) -->
		<div id="itemTitleDisplay" style="position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%) scale(var(--gui-scale)); transform-origin: center bottom; color: white; font-family: 'Minecraftia', monospace; font-size: 11px; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); pointer-events: none; z-index: 1002; opacity: 0; transition: opacity 0.3s ease-in-out; text-align: center;">
			<div id="itemTitleText"></div>
		</div>

		<!-- Dragged Item Cursor (follows mouse when dragging items) -->
		<div id="draggedItemCursor" style="position: fixed; pointer-events: none; z-index: 2000; display: none; image-rendering: pixelated;">
			<div id="draggedItemThumbnail" style="width: 32px; height: 32px;"></div>
			<div id="draggedItemCount" class="item-count" style="position: absolute; bottom: 0; right: 0; font-size: 12px;"></div>
		</div>

		<!-- Health Icons (Survival mode only) - Left side of hotbar -->
		<div id="healthIcons" class="health-icons" style="display: none;"></div>

		<!-- Hunger Icons (Survival mode only) - Right side of hotbar -->
		<div id="hungerIcons" class="hunger-icons" style="display: none;"></div>

		<!-- Creative Inventory Button (only visible in creative mode) -->
		<button id="creativeInventoryButton" class="creative-inventory-button" style="display: none;">
			<img src="media/item/chest.png" alt="Creative Inventory" />
		</button>

		<!-- Hotbar -->
		<div id="hotbar" class="hotbar">
			<div class="hotbar-slot" data-slot="0"></div>
			<div class="hotbar-slot" data-slot="1"></div>
			<div class="hotbar-slot" data-slot="2"></div>
			<div class="hotbar-slot" data-slot="3"></div>
			<div class="hotbar-slot" data-slot="4"></div>
			<div class="hotbar-slot" data-slot="5"></div>
			<div class="hotbar-slot" data-slot="6"></div>
			<div class="hotbar-slot" data-slot="7"></div>
			<div class="hotbar-slot" data-slot="8"></div>
		</div>

		<!-- Mobile Controls (only visible on mobile devices) -->
		<div id="mobileControls" class="mobile-controls" style="display: none;">
			<!-- Left side: Movement joystick -->
			<div class="mobile-joystick-container">
				<div class="mobile-joystick-base" id="joystickBase">
					<div class="mobile-joystick-handle" id="joystickHandle"></div>
				</div>
			</div>

			<!-- Right side: Action buttons -->
			<div class="mobile-buttons-container">
				<!-- Jump button -->
				<button class="mobile-button mobile-button-jump" id="mobileJumpButton" data-action="jump">
					<span>â†‘</span>
				</button>
				
				<!-- Attack/Place buttons row -->
				<div class="mobile-action-row">
					<button class="mobile-button mobile-button-attack" id="mobileAttackButton" data-action="attack">
						<span>âš”</span>
					</button>
					<button class="mobile-button mobile-button-place" id="mobilePlaceButton" data-action="place">
						<span>ðŸ”¨</span>
					</button>
				</div>
			</div>

			<!-- Center: Look around area (invisible touch area) -->
			<div class="mobile-look-area" id="mobileLookArea"></div>
		</div>

		<!-- Creative Inventory Menu -->
		<div id="creativeInventory" class="creative-inventory" style="display: none;">
			<div class="creative-inventory-overlay"></div>
			<div class="creative-inventory-container">
				<div class="creative-inventory-header">
					<h2>Inventario Creativo</h2>
					<button class="creative-inventory-close" id="creativeInventoryCloseButton">Ã—</button>
				</div>
				<div id="creativeInventoryGrid" class="creative-inventory-grid">
					<!-- Blocks will be populated here -->
				</div>
			</div>
		</div>

		<!-- Inventory -->
		<div id="inventory" class="inventory" style="display: none;">
			<div id="inventoryOverlay" class="inventory-overlay"></div>
			<div class="inventory-container">
				<!-- Armor slots (top left) -->
				<div class="inventory-armor">
					<div class="inventory-slot armor-slot" data-type="helmet"></div>
					<div class="inventory-slot armor-slot" data-type="chestplate"></div>
					<div class="inventory-slot armor-slot" data-type="leggings"></div>
					<div class="inventory-slot armor-slot" data-type="boots"></div>
				</div>
				
				<!-- Player model area (left of armor) -->
				<div class="inventory-player-model">
					<canvas id="inventoryPlayerCanvas" class="inventory-player-canvas"></canvas>
				</div>
				
				<!-- Crafting grid 2x2 (top right, like vanilla Minecraft) -->
				<div class="inventory-crafting-area">
					<div class="inventory-crafting-grid">
						<div class="inventory-crafting-slot" data-craft-inv="0"></div>
						<div class="inventory-crafting-slot" data-craft-inv="1"></div>
						<div class="inventory-crafting-slot" data-craft-inv="2"></div>
						<div class="inventory-crafting-slot" data-craft-inv="3"></div>
					</div>
					<div class="inventory-crafting-arrow"></div>
					<div class="inventory-crafting-result">
						<div class="inventory-crafting-result-slot" id="inventoryCraftingResult"></div>
					</div>
				</div>
				
				<!-- Main inventory grid (center) -->
				<div class="inventory-grid">
					<!-- 9 rows x 9 columns = 36 slots -->
				</div>
				
				<!-- Inventory hotbar (bottom) -->
				<div class="inventory-hotbar">
					<div class="inventory-slot" data-inv-slot="0"></div>
					<div class="inventory-slot" data-inv-slot="1"></div>
					<div class="inventory-slot" data-inv-slot="2"></div>
					<div class="inventory-slot" data-inv-slot="3"></div>
					<div class="inventory-slot" data-inv-slot="4"></div>
					<div class="inventory-slot" data-inv-slot="5"></div>
					<div class="inventory-slot" data-inv-slot="6"></div>
					<div class="inventory-slot" data-inv-slot="7"></div>
					<div class="inventory-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Crafting Table GUI -->
		<div id="craftingTable" class="crafting-table" style="display: none;">
			<div id="craftingTableOverlay" class="crafting-table-overlay"></div>
			<div class="crafting-table-container">
				<!-- Crafting grid 3x3 -->
				<div class="crafting-table-grid">
					<div class="crafting-table-slot" data-craft-table="0"></div>
					<div class="crafting-table-slot" data-craft-table="1"></div>
					<div class="crafting-table-slot" data-craft-table="2"></div>
					<div class="crafting-table-slot" data-craft-table="3"></div>
					<div class="crafting-table-slot" data-craft-table="4"></div>
					<div class="crafting-table-slot" data-craft-table="5"></div>
					<div class="crafting-table-slot" data-craft-table="6"></div>
					<div class="crafting-table-slot" data-craft-table="7"></div>
					<div class="crafting-table-slot" data-craft-table="8"></div>
				</div>
				
				<!-- Crafting arrow -->
				<div class="crafting-table-arrow"></div>
				
				<!-- Crafting output -->
				<div class="crafting-table-output">
					<div class="crafting-table-result" data-craft-table="output"></div>
				</div>
				
				<!-- Player inventory (below crafting area) -->
				<div class="crafting-table-inventory-grid">
					<!-- 3 rows x 9 columns -->
				</div>
				
				<!-- Hotbar (bottom) -->
				<div class="crafting-table-hotbar">
					<div class="crafting-table-slot" data-inv-slot="0"></div>
					<div class="crafting-table-slot" data-inv-slot="1"></div>
					<div class="crafting-table-slot" data-inv-slot="2"></div>
					<div class="crafting-table-slot" data-inv-slot="3"></div>
					<div class="crafting-table-slot" data-inv-slot="4"></div>
					<div class="crafting-table-slot" data-inv-slot="5"></div>
					<div class="crafting-table-slot" data-inv-slot="6"></div>
					<div class="crafting-table-slot" data-inv-slot="7"></div>
					<div class="crafting-table-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Pause overlay -->
		<div id="pauseOverlay" class="gui-overlay" style="display: none;"></div>

		<!-- World Selection Menu (shown before game starts) -->
		<div id="worldSelectionMenu" class="gui" style="display: flex;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Seleccionar Mundo</h2>
				</div>
				<div class="world-list-container">
					<div id="worldList" class="world-list">
						<!-- Worlds will be populated here -->
						<div class="world-empty">Cargando mundos...</div>
					</div>
				</div>
				<div class="world-selection-actions">
					<button id="createWorldButton" class="button">Crear Nuevo Mundo</button>
					<button id="refreshWorldsButton" class="button">Actualizar</button>
				</div>
			</div>
		</div>

		<!-- Create World Menu -->
		<div id="createWorldMenu" class="gui" style="display: none;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Crear Nuevo Mundo</h2>
				</div>
				<div class="world-form">
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Nombre del Mundo:</label>
						<input type="text" id="worldNameInput" class="world-input" placeholder="Nuevo Mundo" maxlength="32" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">TamaÃ±o del Mundo:</label>
						<select id="worldSizeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="64">PequeÃ±o (64x64x64)</option>
							<option value="128" selected>Mediano (128x128x128)</option>
							<option value="256">Grande (256x256x256)</option>
						</select>
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Altura del Terreno Plano:</label>
						<input type="number" id="flatHeightInput" class="world-input" value="4" min="1" max="64" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Modo de Juego:</label>
						<select id="worldGameModeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="0" selected>Supervivencia</option>
							<option value="1">Creativo</option>
							<option value="2">Espectador</option>
						</select>
					</div>
					<div class="world-form-actions">
						<button id="createWorldConfirmButton" class="button">Crear Mundo</button>
						<button id="createWorldCancelButton" class="button">Cancelar</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Pause menu -->
		<div id="pauseMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button id="resumeButton" class="button">Volver al juego</button>
				<button id="pauseSettingsButton" class="button">Ajustes</button>
				<button id="exitButton" class="button" details="guardar-y-salir">Salir al menu principal</button>
			</div>
		</div>

		<!-- Pause settings menu -->
		<div id="pauseSettingsMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button class="button" id="pauseSettingsBackButton">Volver</button>
				<div style="margin: 20px 0;">
					<label for="pauseRenderDistanceSlider" style="color: white; font-family: Minecraftia;">Render Distance: <span id="pauseRenderDistanceValue">8</span> chunks</label><br>
					<input type="range" id="pauseRenderDistanceSlider" min="4" max="16" value="8" step="1" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label for="pauseGuiScaleSlider" style="color: white; font-family: Minecraftia;">GUI Scale: <span id="pauseGuiScaleValue">200</span>%</label><br>
					<input type="range" id="pauseGuiScaleSlider" min="100" max="200" value="200" step="10" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label style="color: white; font-family: Minecraftia;">
						<input type="checkbox" id="pauseFpsToggle" style="margin-right: 10px;">Mostrar FPS
					</label>
				</div>
			</div>
		</div>
		
		<!-- Initialisation code -->
		<script type="text/javascript">
			
			const DEFAULT_SEED_NAME = "flat_default_seed";
			const SEED_API_ENDPOINT = "api/seeds.php";
			const ACTIVE_SEED_KEY = "activeSeedName";
			const SEED_SELECTION_KEY = "selectedSeed";

			var world;
			var render;
			var physics;
			var player;

			// Game state
			var paused = false;
			var gameLoopInterval;
			
			// Debug state
			var debugEnabled = false;
			var debugChunksEnabled = false;

			// FPS tracking
			var fps = 0;
			var lastTime = performance.now();
			var frameCount = 0;
			var lastFrameTime = null; // Will be initialized in startGameLoop

			// Performance profiling
			var performanceStats = {
				physics: { total: 0, count: 0, max: 0 },
				playerUpdate: { total: 0, count: 0, max: 0 },
				buildChunks: { total: 0, count: 0, max: 0 },
				updateChunks: { total: 0, count: 0, max: 0 },
				setCamera: { total: 0, count: 0, max: 0 },
				draw: { total: 0, count: 0, max: 0 },
				total: { total: 0, count: 0, max: 0 }
			};

			function measureTime(statName, fn) {
				var start = performance.now();
				var result = fn();
				var elapsed = performance.now() - start;
				var stat = performanceStats[statName];
				if (stat) {
					stat.total += elapsed;
					stat.count++;
					if (elapsed > stat.max) stat.max = elapsed;
				}
				return result;
			}

			// Make performance stats available globally for debugging
			window.performanceStats = performanceStats;

			function logPerformanceStats() {
				if (performanceStats.total.count === 0) return;
				console.log("=== Performance Stats (last second) ===");
				for (var key in performanceStats) {
					var stat = performanceStats[key];
					if (stat.count > 0) {
						var avg = stat.total / stat.count;
						console.log(key + ": avg=" + avg.toFixed(2) + "ms, max=" + stat.max.toFixed(2) + "ms, calls=" + stat.count);
					}
				}
				// Reset stats
				for (var key in performanceStats) {
					performanceStats[key] = { total: 0, count: 0, max: 0 };
				}
			}

			var pauseRenderDistanceSlider = document.getElementById('pauseRenderDistanceSlider');
			var pauseRenderDistanceValue = document.getElementById('pauseRenderDistanceValue');
			var pauseGuiScaleSlider = document.getElementById('pauseGuiScaleSlider');
			var pauseGuiScaleValue = document.getElementById('pauseGuiScaleValue');
			var pauseFpsToggle = document.getElementById('pauseFpsToggle');

			// Initialize world manager and show selection menu
			initWorldManager();

			async function initWorldManager() {
				// Hide game canvas when showing world selection
				var canvas = document.getElementById("renderSurface");
				if ( canvas ) {
					canvas.style.display = "none";
				}
				
				// Initialize world manager
				try {
					await initializeWorldManager();
					await loadWorldsList();
					setupWorldManagerUI();
				} catch ( error ) {
					console.warn( "Failed to initialize world manager:", error );
					// Show error message
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar mundos. Usando mundo por defecto.</div>';
					}
				}
			}

			async function loadWorldsList() {
				try {
					var worlds = await getAllWorlds();
					var worldList = document.getElementById("worldList");
					if ( !worldList ) return;
					
					if ( worlds.length === 0 ) {
						worldList.innerHTML = '<div class="world-empty">No hay mundos. Crea uno nuevo para comenzar.</div>';
						return;
					}
					
					worldList.innerHTML = "";
					for ( var i = 0; i < worlds.length; i++ ) {
						var worldData = worlds[i];
						var worldItem = createWorldItem( worldData );
						worldList.appendChild( worldItem );
					}
				} catch ( error ) {
					console.error( "Failed to load worlds list:", error );
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar la lista de mundos.</div>';
					}
				}
			}

			function createWorldItem( worldData ) {
				var item = document.createElement("div");
				item.className = "world-item";
				item.setAttribute("data-world-id", worldData.id);
				
				var gameModeNames = { 0: "Supervivencia", 1: "Creativo", 2: "Espectador" };
				var gameModeName = gameModeNames[worldData.gameMode] || "Desconocido";
				
				var createdDate = new Date(worldData.created);
				var dateStr = createdDate.toLocaleDateString();
				
				item.innerHTML = '<div class="world-item-info">' +
					'<div class="world-item-name">' + escapeHtml(worldData.name) + '</div>' +
					'<div class="world-item-details">' + 
						gameModeName + ' | ' + 
						worldData.sizeX + 'x' + worldData.sizeY + 'x' + worldData.sizeZ + ' | ' +
						dateStr +
					'</div>' +
				'</div>' +
				'<div class="world-item-actions">' +
					'<button class="button-small" onclick="playWorld(' + worldData.id + ')">Jugar</button>' +
					'<button class="button-small" onclick="deleteWorld(' + worldData.id + ', this)">Eliminar</button>' +
				'</div>';
				
				// Click on item to play
				item.onclick = function(e) {
					if ( e.target.tagName !== "BUTTON" ) {
						playWorld( worldData.id );
					}
				};
				
				return item;
			}

			function escapeHtml(text) {
				var div = document.createElement("div");
				div.textContent = text;
				return div.innerHTML;
			}

			function setupWorldManagerUI() {
				// Hide hotbar when world selection menu is visible (initial state)
				var worldSelectionMenu = document.getElementById("worldSelectionMenu");
				if (worldSelectionMenu && worldSelectionMenu.style.display === "flex") {
					document.body.classList.add("world-selection-active");
				}
				
				// Inicializar VR Manager si estÃ¡ disponible (en la pantalla de selecciÃ³n de mundos)
				if (typeof VRManager !== "undefined") {
					console.log("VR: Inicializando VRManager en pantalla de selecciÃ³n de mundos...");
					// Crear un renderer temporal solo para VR (no se usarÃ¡ hasta que se cargue un mundo)
					var tempRenderer = { vrManager: null };
					tempRenderer.vrManager = new VRManager(tempRenderer);
					tempRenderer.vrManager.createVRButton("body");
					// Guardar referencia global para usar despuÃ©s
					window.tempVRManager = tempRenderer.vrManager;
				}
				
				// Create world button
				var createButton = document.getElementById("createWorldButton");
				if ( createButton ) {
					createButton.onclick = function() {
						document.getElementById("worldSelectionMenu").style.display = "none";
						document.getElementById("createWorldMenu").style.display = "flex";
						// Remove class to show hotbar when leaving world selection
						document.body.classList.remove("world-selection-active");
					};
				}
				
				// Refresh worlds button
				var refreshButton = document.getElementById("refreshWorldsButton");
				if ( refreshButton ) {
					refreshButton.onclick = function() {
						loadWorldsList();
					};
				}
				
				// Create world form
				var createConfirmButton = document.getElementById("createWorldConfirmButton");
				if ( createConfirmButton ) {
					createConfirmButton.onclick = async function() {
						var name = document.getElementById("worldNameInput").value.trim() || "Nuevo Mundo";
						var size = parseInt(document.getElementById("worldSizeSelect").value) || 128;
						var flatHeight = parseInt(document.getElementById("flatHeightInput").value) || 4;
						var gameMode = parseInt(document.getElementById("worldGameModeSelect").value) || 0;
						
						try {
							var worldData = await createNewWorld( name, size, size, size, flatHeight, gameMode );
							
							// Crear instancia temporal del mundo para generar y guardar todos los chunks base
							var tempWorld = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
							tempWorld.worldId = worldData.id;
							
							// Usar terreno Perlin por defecto (puedes cambiar esto a createFlatWorld para terreno plano)
							// Opciones de terreno Perlin:
							// - baseHeight: Altura base (default: 64)
							// - heightVariation: VariaciÃ³n de altura (default: 12) - menor = menos montaÃ±oso
							// - noiseScale: Escala del ruido, menor = mÃ¡s suave (default: 0.04)
							// - octaves: NÃºmero de capas de detalle (default: 4) - menor = menos detalle
							// - persistence: Persistencia del ruido (default: 0.35) - menor = mÃ¡s suave
							try {
								if (tempWorld.createPerlinWorld && typeof tempWorld.createPerlinWorld === "function") {
									tempWorld.createPerlinWorld(null, {
										baseHeight: 64,
										heightVariation: 12, // Reducido para terreno menos montaÃ±oso
										noiseScale: 0.04, // MÃ¡s suave
										octaves: 4, // Menos detalle
										persistence: 0.35 // MÃ¡s suave
									});
									
									// Guardar informaciÃ³n de Perlin en worldData para poder cargarlo despuÃ©s
									worldData.usePerlinTerrain = true;
									worldData.perlinSeed = tempWorld.terrainGenerator ? tempWorld.terrainGenerator.perlin.seed : null;
									worldData.perlinBaseHeight = 64;
									worldData.perlinHeightVariation = 12;
									worldData.perlinNoiseScale = 0.04;
									worldData.perlinOctaves = 4;
									worldData.perlinPersistence = 0.35;
									
									// Actualizar el spawn en worldData con el spawn correcto del terreno Perlin
									if (tempWorld.spawn) {
										worldData.spawn = {
											x: tempWorld.spawn.x,
											y: tempWorld.spawn.y,
											z: tempWorld.spawn.z
										};
										// Guardar el spawn y metadata de Perlin actualizados en IndexedDB
										await updateWorldMetadata(worldData.id, { 
											spawn: worldData.spawn,
											usePerlinTerrain: worldData.usePerlinTerrain,
											perlinSeed: worldData.perlinSeed,
											perlinBaseHeight: worldData.perlinBaseHeight,
											perlinHeightVariation: worldData.perlinHeightVariation,
											perlinNoiseScale: worldData.perlinNoiseScale,
											perlinOctaves: worldData.perlinOctaves,
											perlinPersistence: worldData.perlinPersistence
										});
									}
								} else {
									// Fallback a terreno plano si createPerlinWorld no estÃ¡ disponible
									console.warn("createPerlinWorld no estÃ¡ disponible, usando terreno plano");
									tempWorld.createFlatWorld( flatHeight );
								}
							} catch (err) {
								console.error("Error al crear mundo Perlin:", err);
								console.warn("Usando terreno plano como fallback");
								tempWorld.createFlatWorld( flatHeight );
							}
							
							// Generar y guardar todos los chunks base en IndexedDB
							console.log("Generating and saving all base chunks for new world with Perlin terrain...");
							await tempWorld.generateAndSaveAllChunks();
							console.log("World created and all chunks saved!");
							
							await loadWorldsList();
							document.getElementById("createWorldMenu").style.display = "none";
							document.getElementById("worldSelectionMenu").style.display = "flex";
							// Add class to hide hotbar when showing world selection
							document.body.classList.add("world-selection-active");
							// Reset form
							document.getElementById("worldNameInput").value = "";
							document.getElementById("worldSizeSelect").value = "128";
							document.getElementById("flatHeightInput").value = "4";
							document.getElementById("worldGameModeSelect").value = "0";
						} catch ( error ) {
							console.error( "Failed to create world:", error );
							alert( "Error al crear el mundo: " + error.message );
						}
					};
				}
				
				var createCancelButton = document.getElementById("createWorldCancelButton");
				if ( createCancelButton ) {
					createCancelButton.onclick = function() {
						document.getElementById("createWorldMenu").style.display = "none";
						document.getElementById("worldSelectionMenu").style.display = "flex";
						// Add class to hide hotbar when showing world selection
						document.body.classList.add("world-selection-active");
						// Reset form
						document.getElementById("worldNameInput").value = "";
						document.getElementById("worldSizeSelect").value = "128";
						document.getElementById("flatHeightInput").value = "4";
						document.getElementById("worldGameModeSelect").value = "0";
					};
				}
			}

			// Global functions for world actions
			window.playWorld = async function(worldId) {
				try {
					var worldData = await getWorldById(worldId);
					world = await loadWorldFromData(worldData);
					
					// Hide world selection menu
					document.getElementById("worldSelectionMenu").style.display = "none";
					document.getElementById("createWorldMenu").style.display = "none";
					// Remove class to show hotbar when leaving world selection
					document.body.classList.remove("world-selection-active");
					
					// Show game canvas
					var canvas = document.getElementById("renderSurface");
					if ( canvas ) {
						canvas.style.display = "block";
					}
					
					// Start game
					setupGameSystems();
					initialisePauseSettings();
					
					// Ocultar botÃ³n VR durante el gameplay
					var vrButton = document.getElementById('vr-button');
					if (vrButton) {
						vrButton.style.display = 'none';
					}
					
					// Load player data after player is created
					try {
						var playerData = await loadPlayerDataFromWorld(worldId);
						
						// If no data in IndexedDB, try localStorage backup
						if (!playerData) {
							var backupData = localStorage.getItem('player_backup_' + worldId);
							if (backupData) {
								try {
									playerData = JSON.parse(backupData);
									console.log("Loaded player data from backup");
									// Clear backup after loading
									localStorage.removeItem('player_backup_' + worldId);
								} catch (e) {
									console.warn("Could not parse backup player data:", e);
								}
							}
						}
						
						if (playerData && player) {
							player.loadPlayerData(playerData);
							console.log("Player data loaded successfully");
						}
					} catch (e) {
						console.warn("Could not load player data:", e);
					}
					
					startGameLoop();
				} catch ( error ) {
					console.error( "Failed to load world:", error );
					alert( "Error al cargar el mundo: " + error.message );
				}
			};

			window.deleteWorld = async function(worldId, buttonElement) {
				if ( !confirm( "Â¿EstÃ¡s seguro de que quieres eliminar este mundo? Esta acciÃ³n no se puede deshacer." ) ) {
					return;
				}
				
				try {
					await deleteWorldById(worldId);
					// Remove from list
					if ( buttonElement ) {
						var worldItem = buttonElement.closest(".world-item");
						if ( worldItem ) {
							worldItem.remove();
						}
					}
					// Reload list
					await loadWorldsList();
				} catch ( error ) {
					console.error( "Failed to delete world:", error );
					alert( "Error al eliminar el mundo: " + error.message );
				}
			};
			
			// loadWorldFromData( worldData )
			//
			// Loads a world from world metadata.
			
			async function loadWorldFromData( worldData ) {
				var w = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
				w.worldId = worldData.id;
				w.flatHeight = worldData.flatHeight || 4; // Store flatHeight for chunk generation
				w.gameMode = worldData.gameMode !== undefined ? worldData.gameMode : 0; // Store gameMode (default: Survival)
				
				// Set spawn position first (temporary, will be adjusted if needed)
				if ( worldData.spawn ) {
					w.spawn = new Vector( worldData.spawn.x, worldData.spawn.y, worldData.spawn.z );
				} else {
					w.spawn = new Vector( worldData.sizeX / 2 + 0.5, worldData.flatHeight + 1, worldData.sizeZ / 2 + 0.5 );
				}
				
				// Si el mundo fue creado con Perlin, inicializar el terrainGenerator
				// Detectar si es un mundo Perlin (si tiene usePerlinTerrain o el spawn estÃ¡ muy alto)
				var isPerlinWorld = worldData.usePerlinTerrain || 
				                    (worldData.spawn && worldData.spawn.y > (worldData.flatHeight || 4) + 20);
				
				if (isPerlinWorld && typeof TerrainGenerator !== "undefined") {
					try {
					// Usar la misma configuraciÃ³n que al crear el mundo
					// Valores por defecto ajustados para terreno menos montaÃ±oso
					w.createPerlinWorld(worldData.perlinSeed || null, {
						baseHeight: worldData.perlinBaseHeight || 64,
						heightVariation: worldData.perlinHeightVariation || 12, // Reducido para menos montaÃ±as
						noiseScale: worldData.perlinNoiseScale || 0.04, // MÃ¡s suave
						octaves: worldData.perlinOctaves || 4, // Menos detalle
						persistence: worldData.perlinPersistence || 0.35 // MÃ¡s suave
					});
						
						// Recalcular spawn si es necesario para asegurar que estÃ© sobre el terreno
						if (w.terrainGenerator) {
							var spawnHeight = w.terrainGenerator.getHeightAt(w.spawn.x, w.spawn.z);
							var minSpawnY = spawnHeight + 3;
							if (w.spawn.y < minSpawnY) {
								w.spawn.y = minSpawnY;
								console.log("Spawn ajustado a altura del terreno:", w.spawn.y);
							}
						}
					} catch (err) {
						console.warn("Error al inicializar terreno Perlin, usando terreno plano:", err);
						w.usePerlinTerrain = false;
						w.terrainGenerator = null;
					}
				}
				
				// Don't generate the entire world - chunks will be loaded on demand
				// This prevents loading everything into RAM
				
				return w;
			}
			
			// FunciÃ³n auxiliar para actualizar metadata del mundo
			async function updateWorldMetadata(worldId, updates) {
				if (!worldManager || !worldManager.db) return;
				return new Promise(function(resolve, reject) {
					var transaction = worldManager.db.transaction(["worlds"], "readwrite");
					var store = transaction.objectStore("worlds");
					var request = store.get(worldId);
					
					request.onsuccess = function() {
						var worldData = request.result;
						if (worldData) {
							for (var key in updates) {
								worldData[key] = updates[key];
							}
							worldData.modified = Date.now();
							var putRequest = store.put(worldData);
							putRequest.onsuccess = resolve;
							putRequest.onerror = reject;
						} else {
							resolve();
						}
					};
					request.onerror = reject;
				});
			}

			function fetchSeedDefinition( seedName ) {
				return fetch( SEED_API_ENDPOINT + "?name=" + encodeURIComponent( seedName ), { cache: "no-store" } )
					.then( function( response ) {
						if ( !response.ok ) {
							throw new Error( "Seed API devolviÃ³ " + response.status );
						}
						return response.json();
					} );
			}

			function buildWorldFromSeed( seedDefinition, seedName ) { // this is an example of beta world, this should be removed
				var sx = seedDefinition.sx || 255;
				var sy = seedDefinition.sy || 255;
				var sz = seedDefinition.sz || 255;
				var chunkSize = seedDefinition.chunkSize || 8;
				var chunkSizeY = 256; // Chunks de 8x8x256 (X, Z, Y) para optimizar aire - Y es vertical (altura)
				var w = new World( sx, sy, sz );
				if ( w.setChunking ) w.setChunking( chunkSize, chunkSizeY );

				if ( Array.isArray( seedDefinition.chunks ) && seedDefinition.chunks.length ) {
					preloadSeedChunks( w, seedDefinition.chunks, seedName );
				} else if ( typeof seedDefinition.blocks === "string" && seedDefinition.blocks.length ) {
					w.createFromString( seedDefinition.blocks );
				} else if ( typeof seedDefinition.height === "number" ) {
					w.createFlatWorld( seedDefinition.height );
				} else {
					w.createFlatWorld( 256 );
				}

				var spawn = seedDefinition.spawn || [ sx / 2 + 0.5, sy / 2 + 0.5, 64 ];
				w.spawn = new Vector( spawn[0], spawn[1], spawn[2] );
				return w;
			}

			function preloadSeedChunks( worldInstance, chunks, seedName ) {
				if ( typeof localStorage === "undefined" ) return;

				var previousSeed = localStorage.getItem( ACTIVE_SEED_KEY );
				if ( previousSeed !== seedName ) {
					clearStoredChunkCache( worldInstance.chunkStoragePrefix );
				}

				for ( var i = 0; i < chunks.length; i++ ) {
					var chunkDef = chunks[i];
					if ( typeof chunkDef.data !== "string" ) continue;
					var key = chunkDef.cx + "|" + chunkDef.cy + "|" + chunkDef.cz;
					try {
						localStorage.setItem( worldInstance.chunkStoragePrefix + key, chunkDef.data );
						if ( worldInstance.chunkStates ) worldInstance.chunkStates[key] = "stored";
					} catch ( e ) {
						console.warn( "No se pudo guardar el chunk " + key + " en localStorage.", e );
						break;
					}
				}

				localStorage.setItem( ACTIVE_SEED_KEY, seedName );
			}

			function clearStoredChunkCache( prefix ) {
				if ( typeof localStorage === "undefined" ) return;
				var keysToDelete = [];
				for ( var i = 0; i < localStorage.length; i++ ) {
					var key = localStorage.key( i );
					if ( key && key.indexOf( prefix ) === 0 ) keysToDelete.push( key );
				}
				for ( var k = 0; k < keysToDelete.length; k++ ) {
					localStorage.removeItem( keysToDelete[k] );
				}
			}

			function buildFallbackWorld() {
				var fallbackWorld = new World( 128, 128, 128 );
				fallbackWorld.createFlatWorld( 4 );
				return fallbackWorld;
			}

			// Mobile controls setup
			function setupMobileControls() {
				// Detecta si el dispositivo es mÃ³vil O si el aspect ratio es vertical
				function isMobileOrPortrait() {
					const isUserAgentMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
					const hasTouch = ('ontouchstart' in window);
					const ar = window.innerHeight / window.innerWidth;
					return isUserAgentMobile || hasTouch || (ar > 1.1);
				}

				// Detecta si hay gamepads conectados
				function hasGamepadConnected() {
					if (!navigator.getGamepads) return false;
					var gamepads = navigator.getGamepads();
					for (var i = 0; i < gamepads.length; i++) {
						if (gamepads[i] !== null) {
							return true;
						}
					}
					return false;
				}

				function updateMobileControlsVisibility() {
					var mobileControls = document.getElementById('mobileControls');
					if (!mobileControls) return;
					const shouldShowMobile = isMobileOrPortrait();
					const hasGamepad = hasGamepadConnected();
					// Si hay gamepad, ocultar GUI mÃ³vil incluso si estÃ¡ en modo mÃ³vil
					const enable = shouldShowMobile && !hasGamepad;
					console.log('Mobile controls visible?', enable, '| w:', window.innerWidth, 'h:', window.innerHeight, 'ar:', (window.innerHeight/window.innerWidth).toFixed(2), '| gamepad:', hasGamepad);
					if (enable) {
						mobileControls.style.display = 'block';
						document.body.classList.add('mobile-mode');
					} else {
						mobileControls.style.display = 'none';
						document.body.classList.remove('mobile-mode');
					}
				}

				updateMobileControlsVisibility();
				window.addEventListener('resize', updateMobileControlsVisibility);
				window.addEventListener('orientationchange', updateMobileControlsVisibility);
				
				// Escuchar eventos de gamepad conectado/desconectado
				window.addEventListener('gamepadconnected', function(e) {
					console.log('Gamepad conectado:', e.gamepad.id);
					updateMobileControlsVisibility();
				});
				window.addEventListener('gamepaddisconnected', function(e) {
					console.log('Gamepad desconectado:', e.gamepad.id);
					updateMobileControlsVisibility();
				});
				
				// Verificar gamepads periÃ³dicamente (algunos navegadores no disparan eventos correctamente)
				setInterval(function() {
					if (hasGamepadConnected() !== document.body.classList.contains('gamepad-active')) {
						if (hasGamepadConnected()) {
							document.body.classList.add('gamepad-active');
						} else {
							document.body.classList.remove('gamepad-active');
						}
						updateMobileControlsVisibility();
					}
				}, 1000); // Verificar cada segundo
				
				// Joystick setup
				var joystickBase = document.getElementById('joystickBase');
				var joystickHandle = document.getElementById('joystickHandle');
				var mobileLookArea = document.getElementById('mobileLookArea');
				
				if (!joystickBase || !joystickHandle) return;
				
				var joystickActive = false;
				var joystickCenterX = 0;
				var joystickCenterY = 0;
				var joystickRadius = 0;
				var joystickTouchId = null;
				
				// Calculate joystick center and radius
				function updateJoystickBounds() {
					var rect = joystickBase.getBoundingClientRect();
					joystickCenterX = rect.left + rect.width / 2;
					joystickCenterY = rect.top + rect.height / 2;
					joystickRadius = rect.width / 2 - 30; // Leave space for handle
				}
				
				updateJoystickBounds();
				window.addEventListener('resize', updateJoystickBounds);
				
				// Joystick touch handlers
				function handleJoystickStart(e) {
					e.preventDefault();
					var touch = e.touches ? e.touches[0] : e;
					joystickTouchId = touch.identifier;
					joystickActive = true;
					updateJoystickBounds();
					handleJoystickMove(e);
				}
				
				function handleJoystickMove(e) {
					if (!joystickActive) return;
					e.preventDefault();
					
					var touch = null;
					if (e.touches) {
						for (var i = 0; i < e.touches.length; i++) {
							if (e.touches[i].identifier === joystickTouchId) {
								touch = e.touches[i];
								break;
							}
						}
					} else if (e.changedTouches) {
						for (var i = 0; i < e.changedTouches.length; i++) {
							if (e.changedTouches[i].identifier === joystickTouchId) {
								touch = e.changedTouches[i];
								break;
							}
						}
					} else {
						touch = e;
					}
					
					if (!touch) return;
					
					var deltaX = touch.clientX - joystickCenterX;
					var deltaY = touch.clientY - joystickCenterY;
					var distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
					
					// Clamp to joystick radius
					if (distance > joystickRadius) {
						deltaX = (deltaX / distance) * joystickRadius;
						deltaY = (deltaY / distance) * joystickRadius;
						distance = joystickRadius;
					}
					
					// Update handle position
					joystickHandle.style.transform = 'translate(calc(-50% + ' + deltaX + 'px), calc(-50% + ' + deltaY + 'px))';
					
					// Normalize to -1 to 1 range
					var moveX = deltaX / joystickRadius;
					var moveZ = deltaY / joystickRadius;
					
					// Update player movement keys
					if (player) {
						// Convert joystick input to WASD keys
						// moveX: -1 (left) to 1 (right) -> 'a' (left) to 'd' (right)
						// moveZ: -1 (up/forward) to 1 (down/back) -> 'w' (forward) to 's' (back)
						player.keys['a'] = moveX < -0.1;
						player.keys['d'] = moveX > 0.1;
						player.keys['w'] = moveZ < -0.1;
						player.keys['s'] = moveZ > 0.1;
					}
				}
				
				function handleJoystickEnd(e) {
					if (!joystickActive) return;
					e.preventDefault();
					
					var touch = null;
					if (e.changedTouches) {
						for (var i = 0; i < e.changedTouches.length; i++) {
							if (e.changedTouches[i].identifier === joystickTouchId) {
								touch = e.changedTouches[i];
								break;
							}
						}
					}
					
					if (!touch || touch.identifier !== joystickTouchId) return;
					
					joystickActive = false;
					joystickTouchId = null;
					joystickHandle.style.transform = 'translate(-50%, -50%)';
					
					// Reset movement keys
					if (player) {
						player.keys['a'] = false;
						player.keys['d'] = false;
						player.keys['w'] = false;
						player.keys['s'] = false;
					}
				}
				
				joystickBase.addEventListener('touchstart', handleJoystickStart, { passive: false });
				joystickBase.addEventListener('touchmove', handleJoystickMove, { passive: false });
				joystickBase.addEventListener('touchend', handleJoystickEnd, { passive: false });
				joystickBase.addEventListener('touchcancel', handleJoystickEnd, { passive: false });
				
				// Look around area - estilo Minecraft PE
				// Toda el Ã¡rea del canvas es sensible al touch para mover la cÃ¡mara
				var lookTouchId = null;
				var lastLookX = 0;
				var lastLookY = 0;
				var canvas = document.getElementById('renderSurface');
				
				function handleLookStart(e) {
					// No procesar si se toca un control mÃ³vil
					if (e.target && (e.target.closest('.mobile-button') || e.target.closest('.mobile-joystick-container') || e.target.closest('#mobileControls'))) {
						return;
					}
					e.preventDefault();
					var touch = e.touches ? e.touches[0] : e;
					lookTouchId = touch.identifier;
					lastLookX = touch.clientX;
					lastLookY = touch.clientY;
				}
				
				function handleLookMove(e) {
					if (lookTouchId === null) return;
					e.preventDefault();
					
					var touch = null;
					if (e.touches) {
						for (var i = 0; i < e.touches.length; i++) {
							if (e.touches[i].identifier === lookTouchId) {
								touch = e.touches[i];
								break;
							}
						}
					}
					
					if (!touch) return;
					
					var deltaX = touch.clientX - lastLookX;
					var deltaY = touch.clientY - lastLookY;
					
					// Usar onMouseMove del player para comportamiento idÃ©ntico a pointer lock
					if (player && player.onMouseMove) {
						player.onMouseMove(deltaX, deltaY);
					} else if (player) {
						// Fallback con sensibilidad similar a Minecraft PE
						var sensitivity = 0.002; // Sensibilidad ajustada para touch
						if (player.targetPitch !== undefined && player.targetYaw !== undefined) {
							player.targetPitch -= deltaY * sensitivity;
							player.targetYaw += deltaX * sensitivity;
							
							// Clamp pitch
							if (player.targetPitch < -Math.PI/2) player.targetPitch = -Math.PI/2;
							if (player.targetPitch > Math.PI/2) player.targetPitch = Math.PI/2;
						}
					}
					
					lastLookX = touch.clientX;
					lastLookY = touch.clientY;
				}
				
				function handleLookEnd(e) {
					if (lookTouchId === null) return;
					e.preventDefault();
					
					var touch = null;
					if (e.changedTouches) {
						for (var i = 0; i < e.changedTouches.length; i++) {
							if (e.changedTouches[i].identifier === lookTouchId) {
								touch = e.changedTouches[i];
								break;
							}
						}
					}
					
					if (!touch || touch.identifier !== lookTouchId) return;
					
					lookTouchId = null;
				}
				
				// Aplicar listeners al canvas completo (como Minecraft PE)
				if (canvas) {
					canvas.addEventListener('touchstart', handleLookStart, { passive: false });
					canvas.addEventListener('touchmove', handleLookMove, { passive: false });
					canvas.addEventListener('touchend', handleLookEnd, { passive: false });
					canvas.addEventListener('touchcancel', handleLookEnd, { passive: false });
				}
				
				// TambiÃ©n mantener el Ã¡rea mÃ³vil por compatibilidad
				if (mobileLookArea) {
					mobileLookArea.addEventListener('touchstart', handleLookStart, { passive: false });
					mobileLookArea.addEventListener('touchmove', handleLookMove, { passive: false });
					mobileLookArea.addEventListener('touchend', handleLookEnd, { passive: false });
					mobileLookArea.addEventListener('touchcancel', handleLookEnd, { passive: false });
				}
				
				// Action buttons
				var jumpButton = document.getElementById('mobileJumpButton');
				var attackButton = document.getElementById('mobileAttackButton');
				var placeButton = document.getElementById('mobilePlaceButton');
				
				if (jumpButton && player) {
					jumpButton.addEventListener('touchstart', function(e) {
						e.preventDefault();
						player.keys[' '] = true; // Space key for jump
					}, { passive: false });
					
					jumpButton.addEventListener('touchend', function(e) {
						e.preventDefault();
						player.keys[' '] = false;
					}, { passive: false });
					
					jumpButton.addEventListener('touchcancel', function(e) {
						e.preventDefault();
						player.keys[' '] = false;
					}, { passive: false });
				}
				
				if (attackButton && player) {
					attackButton.addEventListener('touchstart', function(e) {
						e.preventDefault();
						// Funcionar sin pointer lock (como Minecraft PE)
						if (!player.inventoryOpen && !paused) {
							player.isMouseDown = true;
							player.startBreakingBlock();
						}
					}, { passive: false });
					
					attackButton.addEventListener('touchend', function(e) {
						e.preventDefault();
						if (!player.inventoryOpen && !paused) {
							player.isMouseDown = false;
							player.stopBreakingBlock();
						}
					}, { passive: false });
					
					attackButton.addEventListener('touchcancel', function(e) {
						e.preventDefault();
						if (!player.inventoryOpen && !paused) {
							player.isMouseDown = false;
							player.stopBreakingBlock();
						}
					}, { passive: false });
				}
				
				if (placeButton && player) {
					placeButton.addEventListener('touchstart', function(e) {
						e.preventDefault();
						// Funcionar sin pointer lock (como Minecraft PE)
						if (!player.inventoryOpen && !paused) {
							player.doBlockActionAtCenter(false); // Place block
						}
					}, { passive: false });
				}
				
				// Auto-lock pointer on mobile when game starts
				var canvas = document.getElementById('renderSurface');
				if (canvas) {
					// Try to request pointer lock when user taps on canvas
					canvas.addEventListener('touchstart', function(e) {
						if (!player.pointerLocked && !player.inventoryOpen && !paused) {
							canvas.requestPointerLock = canvas.requestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
							// BLOQUEAR pointer lock si estÃ¡ en modo mÃ³vil
							if (canvas.requestPointerLock && !document.body.classList.contains('mobile-mode')) {
								canvas.requestPointerLock();
							} else if (document.body.classList.contains('mobile-mode')) {
								console.log('[MWEB] Pointer lock bloqueado en modo mÃ³vil.');
							}
						}
					}, { passive: false });
				}
				
				console.log('Mobile controls initialized');
			}
			
			function setupGameSystems() {
				render = new Renderer( "renderSurface" );
				render.setWorld( world, 8, 256 ); // Chunks de 8x8x256 para optimizar aire
				render.setPerspective( 60, 0.01, 200 );
				
				// Inicializar VR Manager si estÃ¡ disponible (usar el que ya se creÃ³ en setupWorldManagerUI)
				console.log("VR: Verificando si VRManager estÃ¡ disponible...", typeof VRManager);
				if (typeof VRManager !== "undefined") {
					// Verificar que el renderer tenga canvas y gl antes de asignarlo al VRManager
					if (!render.canvas) {
						console.error("VR: Renderer no tiene canvas asignado");
						var canvasElement = document.getElementById("renderSurface");
						if (canvasElement) {
							console.log("VR: Asignando canvas al renderer desde el DOM");
							render.canvas = canvasElement;
						}
					}
					
					if (!render.gl && render.canvas) {
						console.error("VR: Renderer no tiene contexto WebGL, intentando obtenerlo");
						try {
							render.gl = render.canvas.getContext("webgl", { xrCompatible: true }) || 
							            render.canvas.getContext("experimental-webgl", { xrCompatible: true });
							if (render.gl) {
								console.log("VR: Contexto WebGL obtenido correctamente");
							}
						} catch (e) {
							console.error("VR: Error al obtener contexto WebGL:", e);
						}
					}
					
					// Si ya existe un VRManager temporal, reutilizarlo y actualizar su renderer
					if (window.tempVRManager) {
						console.log("VR: Reutilizando VRManager existente...");
						console.log("VR: Verificando renderer antes de asignar:", {
							render: render,
							hasCanvas: !!render.canvas,
							hasGl: !!render.gl
						});
						
						window.tempVRManager.renderer = render;
						
						// Verificar que el renderer asignado tenga canvas y gl
						if (!window.tempVRManager.renderer.canvas) {
							console.error("VR: ERROR: Renderer asignado no tiene canvas");
						}
						if (!window.tempVRManager.renderer.gl) {
							console.error("VR: ERROR: Renderer asignado no tiene gl");
						}
						
						// Actualizar las matrices originales ahora que el renderer estÃ¡ completo
						if (render.projMatrix && render.viewMatrix) {
							window.tempVRManager.originalProjMatrix = render.projMatrix;
							window.tempVRManager.originalViewMatrix = render.viewMatrix;
						}
						render.vrManager = window.tempVRManager;
						window.tempVRManager = null; // Limpiar referencia temporal
					} else {
						console.log("VR: Creando nuevo VRManager...");
						render.vrManager = new VRManager(render);
						// El botÃ³n ya deberÃ­a estar creado, solo actualizar la referencia
						var button = document.getElementById('vr-button');
						if (button && render.vrManager) {
							render.vrManager.vrButton = button;
						}
					}
				} else {
					console.warn("VR: VRManager no estÃ¡ definido. Â¿Se cargÃ³ js/vr.js?");
				}

				physics = new Physics();
				physics.setWorld( world );
				// Agregar referencia a physics en el world para que el renderer pueda acceder
				world.physics = physics;

				player = new Player();
				player.setWorld( world );
				player.setPhysics( physics );
				player.setInputCanvas( "renderSurface" );
				player.initInventory();
				
				// Set game mode from world data
				if ( world.gameMode !== undefined ) {
					player.setGameMode( world.gameMode );
				}
				
				// Setup debug key handlers
				setupDebugKeys();
				
				// Setup mobile controls (after player is initialized)
				setupMobileControls();

				// Override updateMobileControlsVisibility to handle pointer lock
				// This must be done after setupMobileControls() is called
				const origUpdateMobileControlsVisibility = window.updateMobileControlsVisibility;
				window.updateMobileControlsVisibility = function() {
					// Call original function first
					if (origUpdateMobileControlsVisibility) {
						origUpdateMobileControlsVisibility();
					}

					var mobileControls = document.getElementById('mobileControls');
					if (!mobileControls) return;
					const enable = isMobileOrPortrait();
					console.log('Mobile controls visible?', enable, '| w:', window.innerWidth, 'h:', window.innerHeight, 'ar:', (window.innerHeight/window.innerWidth).toFixed(2));
					if (enable) {
						mobileControls.style.display = 'block';
						document.body.classList.add('mobile-mode');
						// Salir de pointer lock si estÃ¡ activo (Minecraft PE no usa pointer lock)
						if (document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement) {
							document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock;
							if (document.exitPointerLock) document.exitPointerLock();
						}
					} else {
						mobileControls.style.display = 'none';
						document.body.classList.remove('mobile-mode');
						// pointer lock se podrÃ¡ volver a activar sÃ³lo si el usuario hace clic explÃ­citamente
					}
				};
			}
			
			function setupDebugKeys() {
				// Interceptar eventos de teclado para F3, C+F3 y F4 (modo espectador)
				var originalOnKeyEvent = player.onKeyEvent;
				player.onKeyEvent = function(keyCode, down) {
					// Llamar al handler original
					originalOnKeyEvent.call(this, keyCode, down);
					
					// F3 key code = 114
					if (keyCode === 114) {
						if (down) {
							// Verificar si C estÃ¡ presionado
							if (this.keys['c'] || this.keys[67]) {
								debugChunksEnabled = !debugChunksEnabled;
								render.showChunkGrid = debugChunksEnabled;
							} else {
								debugEnabled = !debugEnabled;
								document.getElementById('debugOverlay').style.display = debugEnabled ? 'block' : 'none';
							}
						}
					}
					
					// F4 key code = 115 (Modo espectador)
					if (keyCode === 115 && down) {
						if (this.spectatorMode !== undefined) {
							this.spectatorMode = !this.spectatorMode;
							// Resetear velocidad al cambiar de modo
							this.velocity = new Vector( 0, 0, 0 );
							this.falling = false;
							// Forzar primera persona cuando se activa el modo espectador
							if (this.spectatorMode) {
								this.cameraMode = 1;
							}
							console.log('Modo espectador: ' + (this.spectatorMode ? 'ACTIVADO' : 'DESACTIVADO'));
						}
					}
					
					// F5 key code = 116 (Cambio de perspectiva) - manejado en player.js
				};
			}

			// Function to set GUI scale
			function setGuiScale(scale) {
				// scale is a percentage (100-300), convert to decimal (1.0-3.0)
				var scaleDecimal = scale / 100; // 100% = 1.0x, 200% = 2.0x, 300% = 3.0x
				document.documentElement.style.setProperty('--gui-scale', scaleDecimal);
				localStorage.setItem('guiScale', scale);
			}

			// Function to get GUI scale from localStorage or default
			function getGuiScale() {
				var savedScale = localStorage.getItem('guiScale');
				return savedScale ? parseInt(savedScale) : 200; // Default 200%
			}

			function initialisePauseSettings() {
				var savedRenderDistance = localStorage.getItem('renderDistance') || '8';
				pauseRenderDistanceSlider.value = savedRenderDistance;
				pauseRenderDistanceValue.textContent = savedRenderDistance;
				render.setRenderDistance(parseInt(savedRenderDistance));

				var savedGuiScale = getGuiScale();
				pauseGuiScaleSlider.value = savedGuiScale;
				pauseGuiScaleValue.textContent = savedGuiScale;
				setGuiScale(savedGuiScale);

				var savedShowFPS = localStorage.getItem('showFPS') || 'false';
				pauseFpsToggle.checked = savedShowFPS === 'true';
				if (savedShowFPS === 'true') {
					document.getElementById('fpsDisplay').style.display = 'block';
				}
			}

			// Setup Canvas 2D player model for inventory
			function setupInventoryPlayerModelCSS3D() {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) {
					// Try again after a short delay if element not ready
					setTimeout(setupInventoryPlayerModelCSS3D, 100);
					return;
				}
				
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Set canvas size - must match the container size exactly
				// Get the actual size of the container (accounts for GUI scale)
				var container = canvas.parentElement;
				if (container) {
					var rect = container.getBoundingClientRect();
					// Use the actual rendered size (after GUI scale)
					canvas.width = 52; // Base width in pixels (matches container)
					canvas.height = 70; // Base height in pixels (matches container)
					// The CSS will scale it, so we keep base size here
				} else {
					// Fallback to base size
					canvas.width = 52;
					canvas.height = 70;
				}
				
				var container = canvas.parentElement; // .inventory-player-model
				if (!container) return;
				
				// Prevent duplicate event listeners
				if (container._inventoryModelSetup) return;
				container._inventoryModelSetup = true;
				
				// Load player texture
				var playerImage = new Image();
				playerImage.onload = function() {
					// Store image for rendering
					canvas._playerTexture = playerImage;
					// Store ctx and canvas for later use
					canvas._ctx = ctx;
					
					// Ensure rotation state is initialized
					if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
					if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					
					// Initial render
					renderInventoryPlayerModel(ctx, canvas, canvas._modelYaw, canvas._modelPitch);
					
					// If inventory is already open, start render loop now that texture is loaded
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						// Initialize mouse position
						var container = canvas.parentElement;
						if (container && (canvas._lastMouseX === undefined || canvas._lastMouseX === null)) {
							var rect = container.getBoundingClientRect();
							canvas._lastMouseX = rect.left + rect.width / 2;
							canvas._lastMouseY = rect.top + rect.height / 2;
						}
						// Start render loop if not already running
						if (window._startInventoryRenderLoop) {
							window._startInventoryRenderLoop();
						}
					}
				};
				playerImage.src = 'media/player.png';
				
				// Rotation state (stored on canvas for persistence)
				// Use same system as player.js: angles and targetAngles with interpolation
				// player.js: angles[0] = pitch, angles[1] = yaw
				canvas._angles = [0, Math.PI]; // [pitch, yaw] - start facing forward (same as player.js default)
				canvas._targetYaw = Math.PI;
				canvas._targetPitch = 0;
				// Backwards compatibility
				canvas._modelYaw = Math.PI;
				canvas._modelPitch = 0;
				
				// Make canvas and context accessible globally
				window._inventoryPlayerCanvas = canvas;
				window._inventoryPlayerCtx = ctx;
				
				// Global function to update model rotation (accessible from document listener)
				// Model follows mouse anywhere on screen, like in vanilla Minecraft
				window.updateInventoryPlayerModelRotation = function(e) {
					// Check if inventory is open
					var inventory = document.getElementById('inventory');
					if (!inventory || inventory.style.display !== 'flex') {
						return;
					}
					
					var canvas = window._inventoryPlayerCanvas;
					if (!canvas || !canvas._playerTexture || !canvas._ctx) {
						return; // Canvas or texture not ready
					}
					
					var container = canvas.parentElement;
					if (!container) return;
					
					// Get container bounds (accounting for GUI scale)
					var rect = container.getBoundingClientRect();
					
					// Calculate mouse position relative to container center
					var centerX = rect.left + rect.width / 2;
					var centerY = rect.top + rect.height / 2;
					
					// Calculate distance from center (for rotation calculation)
					var deltaX = e.clientX - centerX;
					var deltaY = e.clientY - centerY;
					
					// In vanilla Minecraft, the model rotates directly based on mouse position
					// The rotation range is approximately Â±90 degrees (Ï€/2 radians)
					// Calculate rotation angles based on mouse position relative to center
					// Sensitivity: the model rotates ~Ï€ radians (180Â°) when mouse is at edge of container
					var maxRotation = Math.PI / 2; // Max 90 degrees rotation
					var sensitivity = Math.max(rect.width, rect.height) / 2; // Use max dimension for consistent rotation
					
					// Calculate rotation angles (yaw and pitch)
					// Yaw: rotation around Y axis (horizontal) - based on mouse X position
					var normalizedX = Math.max(-1, Math.min(1, deltaX / sensitivity));
					// Pitch: rotation around X axis (vertical) - based on mouse Y position  
					var normalizedY = Math.max(-1, Math.min(1, deltaY / sensitivity));
					
					// Ensure target angles are initialized
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					
					// Update target angles
					// Base yaw is Math.PI (facing forward/away from camera in inventory)
					// Positive deltaX (mouse right) = rotate model right (increase yaw)
					canvas._targetYaw = Math.PI + (normalizedX * maxRotation);
					
					// Pitch: mouse down = model looks down (negative pitch)
					canvas._targetPitch = -(normalizedY * maxRotation);
					
					// Clamp target pitch to prevent extreme angles
					if (canvas._targetPitch < -Math.PI/2) canvas._targetPitch = -Math.PI/2;
					if (canvas._targetPitch > Math.PI/2) canvas._targetPitch = Math.PI/2;
					
					// Store last mouse event for continuous tracking
					canvas._lastMouseEvent = e;
				};
				
				// Track mouse position constantly - store last position to maintain rotation
				// Store on canvas so it persists across function scopes
				canvas._lastMouseEvent = null;
				
				// Track mouse movement globally (always track, not just when inventory is open)
				// This ensures mouse position is always available when inventory opens
				document.addEventListener('mousemove', function(e) {
					var canvas = window._inventoryPlayerCanvas;
					if (canvas) {
						// Always store mouse position for continuous tracking
						canvas._lastMouseX = e.clientX;
						canvas._lastMouseY = e.clientY;
						canvas._lastMouseEvent = e;
					}
					
					// Check if inventory is open for immediate update
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						// Also update immediately for instant response
						if (window.updateInventoryPlayerModelRotation) {
							window.updateInventoryPlayerModelRotation(e);
						}
					}
				});
				
				// Mouse position is now tracked continuously in mousemove listener above
				// The render loop will use the stored position to update rotation each frame
				
				// Render loop for continuous updates when inventory is open
				// Uses requestAnimationFrame for smooth, browser-synchronized rendering
				// Uses same interpolation system as player.js (line 864-865)
				var renderLoopAnimationFrame = null;
				var lastUpdateTime = Date.now();
				
				var renderFrame = function() {
					var inventory = document.getElementById('inventory');
					// Check if we should continue rendering
					if (inventory && inventory.style.display === 'flex' && canvas && canvas._ctx) {
						// If texture not loaded yet, skip rendering but continue loop
						if (!canvas._playerTexture) {
							renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
							return;
						}
						
						// Ensure angles are initialized
						if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
						if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
						if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
						if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
						
						// Update target angles based on current mouse position (replicating player.js rotation system)
						var container = canvas.parentElement;
						if (container) {
							var rect = container.getBoundingClientRect();
							var centerX = rect.left + rect.width / 2;
							var centerY = rect.top + rect.height / 2;
							
							// Always use stored last mouse position (updated by mousemove listener)
							// If not available yet, use center (default position)
							var mouseX = (canvas._lastMouseX !== undefined && canvas._lastMouseX !== null) ? canvas._lastMouseX : centerX;
							var mouseY = (canvas._lastMouseY !== undefined && canvas._lastMouseY !== null) ? canvas._lastMouseY : centerY;
							
							// Calculate delta from center (like movementX/Y in player.js)
							var deltaX = mouseX - centerX;
							var deltaY = mouseY - centerY;
							
							// Ensure angles are initialized (same as player.js: angles[0] = pitch, angles[1] = yaw)
							if (canvas._angles === undefined) {
								canvas._angles = [0, Math.PI]; // [pitch, yaw] - start facing forward
							}
							if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
							if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
							
							// Update target angles based on mouse position (replicating player.js onMouseMove)
							// player.js: this.targetPitch = this.angles[0] - deltaY / 200;
							//           this.targetYaw = this.angles[1] + deltaX / 200;
							// For inventory: use sensitivity based on container size (similar to /200 sensitivity)
							var sensitivity = 200; // Same sensitivity as player.js
							// Calculate sensitivity multiplier based on container size to match player.js behavior
							var sensitivityMultiplier = Math.max(rect.width, rect.height) / 100; // Adjust based on container size
							
							// Update target angles (replicating player.js onMouseMove logic)
							canvas._targetPitch = canvas._angles[0] - (deltaY / (sensitivity * sensitivityMultiplier));
							canvas._targetYaw = canvas._angles[1] + (deltaX / (sensitivity * sensitivityMultiplier));
							
							// Clamp target pitch (same as player.js)
							if (canvas._targetPitch < -Math.PI/2) canvas._targetPitch = -Math.PI/2;
							if (canvas._targetPitch > Math.PI/2) canvas._targetPitch = Math.PI/2;
						}
						
						// Interpolate angles towards target (same as player.js update() - line 3948-3949)
						// player.js: this.angles[0] += ( this.targetPitch - this.angles[0] ) * 30 * delta;
						//           this.angles[1] += ( this.targetYaw - this.angles[1] ) * 30 * delta;
						var now = Date.now();
						var delta = (now - lastUpdateTime) / 1000; // Convert to seconds
						lastUpdateTime = now;
						
						// Ensure angles array is initialized
						if (canvas._angles === undefined) {
							canvas._angles = [0, Math.PI]; // [pitch, yaw]
						}
						if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
						if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
						
						// Interpolate with same speed as player.js (30 * delta)
						var interpolationSpeed = 30; // Same as player.js
						canvas._angles[0] += (canvas._targetPitch - canvas._angles[0]) * interpolationSpeed * delta;
						canvas._angles[1] += (canvas._targetYaw - canvas._angles[1]) * interpolationSpeed * delta;
						
						// Clamp pitch (same as player.js line 3950-3951)
						if (canvas._angles[0] < -Math.PI/2) canvas._angles[0] = -Math.PI/2;
						if (canvas._angles[0] > Math.PI/2) canvas._angles[0] = Math.PI/2;
						
						// Use interpolated angles for rendering (same as render.js uses player.angles)
						// render.js: Math.PI - player.angles[1] for yaw, -pitch for pitch
						var renderYaw = canvas._angles[1]; // Will be converted to Math.PI - yaw in render function
						var renderPitch = canvas._angles[0]; // Will be converted to -pitch in render function
						
						// Also update model angles for backwards compatibility
						canvas._modelYaw = renderYaw;
						canvas._modelPitch = renderPitch;
						
						// Render with interpolated angles (same as render.js uses player.angles)
						// render.js: Math.PI - player.angles[1] for yaw, -pitch for pitch
						if (canvas._ctx && canvas._playerTexture) {
							// Pass angles as they are - render function will apply Math.PI - yaw and -pitch
							renderInventoryPlayerModel(canvas._ctx, canvas, renderYaw, renderPitch);
						}
						
						// Schedule next frame
						renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
					} else {
						// Stop loop if inventory closed
						if (renderLoopAnimationFrame) {
							cancelAnimationFrame(renderLoopAnimationFrame);
							renderLoopAnimationFrame = null;
							canvas._renderLoopActive = false;
						}
					}
				};
				
				var startRenderLoop = function() {
					// Check if loop already exists (stored on canvas)
					if (canvas._renderLoopActive || renderLoopAnimationFrame) {
						// Already running, just ensure it continues
						return;
					}
					
					// Ensure canvas and context are available
					if (!canvas || !canvas._ctx) {
						console.log('Canvas or context not ready for render loop');
						return;
					}
					
					lastUpdateTime = Date.now();
					canvas._renderLoopActive = true;
					
					// Initialize angles if not set (same as player.js)
					if (canvas._angles === undefined) {
						canvas._angles = [0, Math.PI]; // [pitch, yaw] - same as player.js default
					}
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					// Backwards compatibility
					if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
					if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
					
					// Force initial render if texture is loaded
					if (canvas._playerTexture && canvas._ctx) {
						renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
					}
					
					// Start the animation frame loop
					console.log('Starting inventory render loop');
					renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
				};
				
				// Start render loop when inventory opens
				var inventory = document.getElementById('inventory');
				if (inventory) {
					var observer = new MutationObserver(function(mutations) {
						for (var i = 0; i < mutations.length; i++) {
							var mutation = mutations[i];
							if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
								var display = inventory.style.display;
								if (display === 'flex') {
									// Wait for texture to load if not ready
									if (!canvas._playerTexture) {
										console.log('Waiting for player texture to load...');
										// Texture will load and trigger render, but we should still start the loop
									}
									
									// Initialize mouse position if not set yet
									// Use center of container as default
									var container = canvas.parentElement;
									if (container && (canvas._lastMouseX === undefined || canvas._lastMouseX === null)) {
										var rect = container.getBoundingClientRect();
										canvas._lastMouseX = rect.left + rect.width / 2;
										canvas._lastMouseY = rect.top + rect.height / 2;
									}
									
									// Ensure rotation state is initialized (same as player.js)
									if (canvas._angles === undefined) {
										canvas._angles = [0, Math.PI]; // [pitch, yaw] - same as player.js default
									}
									if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
									if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
									// Backwards compatibility
									if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
									if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
									
									// Store startRenderLoop globally so it can be called when texture loads
									window._startInventoryRenderLoop = startRenderLoop;
									
									// Inventory opened, start render loop
									startRenderLoop();
									
									// Initial render if texture is ready
									setTimeout(function() {
										if (canvas && canvas._ctx && canvas._playerTexture) {
											renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
										}
									}, 10);
								} else if (display === 'none') {
									// Inventory closed, stop render loop and reset rotation
									if (renderLoopAnimationFrame) {
										cancelAnimationFrame(renderLoopAnimationFrame);
										renderLoopAnimationFrame = null;
										canvas._renderLoopActive = false;
									}
									// Reset to default angles (same as player.js: angles = [0, Math.PI, 0])
									canvas._modelYaw = Math.PI;
									canvas._modelPitch = 0;
									canvas._targetYaw = Math.PI;
									canvas._targetPitch = 0;
								}
							}
						}
					});
					observer.observe(inventory, { attributes: true, attributeFilter: ['style'] });
				}
			}
			
			// Global function to render inventory player model (accessible from anywhere)
			window.renderInventoryPlayerModel = function(yaw, pitch) {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) return;
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Use stored rotation if not provided
				if (yaw === undefined) yaw = canvas._modelYaw || 0;
				if (pitch === undefined) pitch = canvas._modelPitch || 0;
				
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			};
			
			// Render the 3D player model using Canvas 2D (same rotation logic as render.js)
			// Model is centered in the canvas and rotates like the player in-game
			function renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch) {
				if (!canvas._playerTexture) {
					console.log('No texture loaded yet');
					return;
				}
				
				// Clear canvas with transparent background
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.imageSmoothingEnabled = false; // Pixelated rendering
				
				var img = canvas._playerTexture;
				var centerX = canvas.width / 2;
				var centerY = canvas.height / 2;
				// Calculate scale to fit model in canvas (52x70px base size, before GUI scale)
				// Model dimensions at scale 1: head (8px) + body (12px) + legs (12px) = 32px height
				// Model width at scale 1: body (8px) + arms (4px each side) â‰ˆ 16px
				// In vanilla Minecraft, the inventory player model is slightly smaller to fit better
				// Adjust scale to match vanilla proportions - scale of 2.0 gives better visibility
				var scale = 2.0; // Increased scale for better visibility, like vanilla Minecraft
				
				var bodyW = 8 * scale;
				var bodyH = 12 * scale;
				var headSize = 8 * scale;
				var armW = 4 * scale;
				var armH = 12 * scale;
				var legW = 4 * scale;
				var legH = 12 * scale;
				
				// Total model height (head + body + legs)
				var totalHeight = headSize + bodyH + legH;
				// Total model width (body + arms on each side)
				var totalWidth = bodyW + armW * 2;
				
				// Clamp pitch like in render.js (line 296-297)
				var clampedPitch = pitch;
				if (clampedPitch < -0.32) clampedPitch = -0.32;
				if (clampedPitch > 0.32) clampedPitch = 0.32;
				
				// Center the model in the canvas (like vanilla Minecraft)
				// Body center Y position: start from top of legs, go up by legH + bodyH/2
				var bodyCenterY = legH + bodyH/2;
				// Head center Y position: above body
				var headCenterY = legH + bodyH + headSize/2;
				// Total model center (vertical center of entire model)
				var modelCenterY = (legH + bodyH + headSize) / 2;
				
				// Offset to center the model in canvas - adjust slightly upward for better positioning
				var verticalOffset = centerY - modelCenterY - (scale * 2); // Slight upward offset for better centering
				
				// Draw body first - rotates with yaw only (like render.js line 319-323)
				ctx.save();
				ctx.translate(centerX, verticalOffset + bodyCenterY);
				// Rotate body with yaw (same as render.js: Math.PI - player.angles[1])
				// Canvas rotates clockwise for positive values, so we need Math.PI - yaw
				ctx.rotate(Math.PI - yaw);
				
				// Draw body centered
				ctx.drawImage(img, 20, 20, 8, 12, -bodyW/2, -bodyH/2, bodyW, bodyH);
				
				// Draw arms attached to body
				ctx.drawImage(img, 44, 20, 4, 12, -bodyW/2 - armW + 2, -armH/2, armW, armH);
				ctx.drawImage(img, 44, 20, 4, 12, bodyW/2 - 2, -armH/2, armW, armH);
				
				// Draw legs (below body)
				ctx.drawImage(img, 4, 20, 4, 12, -bodyW/4 - legW/2, bodyH/2, legW, legH);
				ctx.drawImage(img, 4, 20, 4, 12, bodyW/4 - legW/2, bodyH/2, legW, legH);
				
				// Draw head with rotation (like render.js line 311-312)
				// Head rotates with both yaw and pitch
				// Head position: above body
				var headOffsetY = -bodyH/2 - headSize/2; // Offset from body center to head center
				
				ctx.save();
				// Move to head center position (above body)
				ctx.translate(0, headOffsetY);
				// Apply yaw rotation (same as body, but head can also pitch)
				// In render.js: Math.PI - player.angles[1]
				ctx.rotate(Math.PI - yaw);
				// Apply pitch rotation (like render.js: -pitch)
				// In canvas 2D, we simulate pitch by scaling vertically and adjusting position
				var pitchScale = Math.cos(-clampedPitch); // Scale down when looking up/down
				var pitchOffset = Math.sin(-clampedPitch) * headSize * 0.3; // Offset for perspective
				ctx.scale(1, pitchScale);
				ctx.translate(0, pitchOffset);
				
				// Draw head centered
				ctx.drawImage(img, 8, 8, 8, 8, -headSize/2, -headSize/2, headSize, headSize);
				ctx.restore();
				
				ctx.restore();
			}
			
			// Keep old function name for backward compatibility
			function renderInventoryPlayerModel(ctx, canvas, yaw, pitch) {
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			}

			// Function to start the render loop
			function startGameLoop() {
				// Initialize CSS 3D player model rotation tracking
				setupInventoryPlayerModelCSS3D();
				
				// Use requestAnimationFrame for better performance and synchronization
				lastFrameTime = performance.now(); // Use global variable
				var frameId = null;
				
				function gameLoop(currentTime) {
					if (!paused) {
						var frameStart = performance.now();
						
						// If lastFrameTime is null or very old, reset it to prevent huge delta
						if (lastFrameTime === null || (currentTime - lastFrameTime) > 1000) {
							lastFrameTime = currentTime;
						}
						
						var deltaTime = (currentTime - lastFrameTime) / 1000.0; // Delta in seconds
						lastFrameTime = currentTime;
						
						// Limit delta to prevent large jumps
						if (deltaTime > 0.1) deltaTime = 0.1; // Max 100ms delta

						// Simulate physics
						measureTime('physics', function() {
							physics.simulate(deltaTime);
						});

						// Update animations (debe llamarse cada frame para animaciones suaves)
						if ( physics.updateAnimations ) {
							physics.updateAnimations(deltaTime);
							// Marcar chunks como dirty solo si contienen bloques animados
							if ( Object.keys( physics.fallingBlocks ).length > 0 ) {
								// Marcar solo los chunks que contienen bloques animados
								for ( var key in physics.fallingBlocks ) {
									var anim = physics.fallingBlocks[key];
									// Marcar el chunk que contiene este bloque animado
									render.onBlockChanged( anim.x, anim.startY, anim.z );
									// TambiÃ©n marcar el chunk de destino si es diferente
									if ( anim.targetY != anim.startY ) {
										render.onBlockChanged( anim.x, anim.targetY, anim.z );
									}
								}
							}
						}

						// Update local player
						measureTime('playerUpdate', function() {
							player.update();
						});

						// Build chunks only if there are dirty chunks (optimization)
						measureTime('buildChunks', function() {
							if (render.dirtyChunks && render.dirtyChunks.length > 0) {
								// Build fewer chunks per frame to spread load
								render.buildChunks( 2 ); // Reduced from 8 to 2
							}
						});

						// Draw world
						measureTime('setCamera', function() {
							var eyePos = player.getEyePos();
							var cameraAngles = player.angles.slice(); // Copiar Ã¡ngulos
							
							// Ajustar Ã¡ngulos de la cÃ¡mara segÃºn el modo de perspectiva
							// En modo espectador, solo usar primera persona (no ajustar Ã¡ngulos)
							if ( !player.spectatorMode && player.cameraMode === 2 ) {
								// Segunda persona: cÃ¡mara detrÃ¡s del jugador, mirando hacia donde mira el jugador
								cameraAngles[0] = player.angles[0];
								cameraAngles[1] = player.angles[1];
							} else if ( !player.spectatorMode && player.cameraMode === 3 ) {
								// Tercera persona: cÃ¡mara delante del jugador, conectada rÃ­gidamente a la cabeza
								// Si Steve baja la cabeza, la cÃ¡mara tambiÃ©n baja, pero la cÃ¡mara mira hacia arriba
								// Calcular direcciÃ³n desde la cÃ¡mara hacia el jugador
								var playerEyePos = player.pos.add( new Vector( 0.0, 1.7, 0.0 ) );
								var dx = playerEyePos.x - eyePos.x;
								var dy = playerEyePos.y - eyePos.y;
								var dz = playerEyePos.z - eyePos.z;
								
								// Calcular pitch (Ã¡ngulo vertical) hacia el jugador
								// Cuando el jugador mira hacia abajo (pitch negativo), la cÃ¡mara debe mirar hacia arriba (pitch positivo)
								// Por lo tanto, invertimos el pitch calculado
								var horizontalDist = Math.sqrt(dx * dx + dz * dz);
								if (horizontalDist > 0.001) {
									cameraAngles[0] = Math.atan2(dy, horizontalDist); // Invertido: sin el negativo
								} else {
									cameraAngles[0] = 0; // Si estÃ¡ directamente arriba/abajo, no inclinar
								}
								
								// Calcular yaw (Ã¡ngulo horizontal) hacia el jugador
								// En el sistema del juego, el movimiento usa: Math.cos(Math.PI/2 - yaw) para X y Math.sin(Math.PI/2 - yaw) para Z
								// Esto significa que yaw = 0 apunta hacia el norte (direcciÃ³n positiva de Z)
								// Para calcular el yaw desde la cÃ¡mara hacia el jugador:
								// - Necesitamos el Ã¡ngulo que hace el vector (dx, dz) con el eje Z positivo
								// - Math.atan2(dx, dz) da el Ã¡ngulo desde el eje Z hacia X
								// - Si dx=0 y dz>0 (norte), Math.atan2(0, 1) = 0, y queremos yaw = 0 âœ“
								// - Si dx>0 y dz=0 (este), Math.atan2(1, 0) = PI/2, y queremos yaw = PI/2 âœ“
								// - Por lo tanto, yaw = Math.atan2(dx, dz) es correcto
								if (horizontalDist > 0.001) {
									cameraAngles[1] = Math.atan2(dx, dz);
								} else {
									cameraAngles[1] = player.angles[1]; // Mantener el yaw del jugador si estÃ¡ directamente arriba/abajo
								}
							}
							
							render.setCamera( eyePos.toArray(), cameraAngles );
						});

						measureTime('draw', function() {
							render.draw();
							// Also capture updateChunks time if available
							if (render._updateChunksStats && render._updateChunksStats.count > 0) {
								var stat = render._updateChunksStats;
								var avg = stat.total / stat.count;
								if (!performanceStats.updateChunks) {
									performanceStats.updateChunks = { total: 0, count: 0, max: 0 };
								}
								performanceStats.updateChunks.total += avg * stat.count;
								performanceStats.updateChunks.count += stat.count;
								if (stat.max > performanceStats.updateChunks.max) {
									performanceStats.updateChunks.max = stat.max;
								}
								// Reset renderer stats
								render._updateChunksStats = { total: 0, count: 0, max: 0 };
							}
						});
						
						// Update debug overlay (only if enabled)
						if (debugEnabled) {
							updateDebugOverlay();
						}

						var frameTime = performance.now() - frameStart;
						measureTime('total', function() { return frameTime; });

						// Calculate FPS
						var currentTime = performance.now();
						frameCount++;
						if (currentTime - lastTime >= 1000) {
							fps = frameCount;
							frameCount = 0;
							lastTime = currentTime;
							if (document.getElementById('fpsDisplay').style.display !== 'none') {
								document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
							}
							// Log performance stats every second
							logPerformanceStats();
						}
					} else {
						// Game is paused - reset lastFrameTime so we don't accumulate a huge delta
						// This prevents massive catch-up when resuming
						lastFrameTime = performance.now();
					}
					
					// Always schedule next frame, but only process game logic if not paused
					frameId = requestAnimationFrame(gameLoop);
				}
				
				// Start the loop
				frameId = requestAnimationFrame(gameLoop);
				gameLoopInterval = { frameId: frameId, cancel: function() { if (this.frameId) cancelAnimationFrame(this.frameId); } }; // Store for cleanup
			}

			// Update debug overlay with player information
			function updateDebugOverlay() {
				if (!player || !world) return;
				
				var pos = player.pos;
				var eyePos = player.getEyePos();
				var angles = player.angles;
				
				// Calcular bloque actual (donde estÃ¡ el jugador)
				// Ejes: X y Z = horizontal, Y = vertical (altura)
				var blockX = Math.floor(pos.x);
				var blockY = Math.floor(pos.y);
				var blockZ = Math.floor(pos.z);
				var block = world.getBlock(blockX, blockY, blockZ);
				
				// Intentar obtener el bloque que el jugador estÃ¡ mirando (usando pickAt)
				var lookedBlock = null;
				var lookedBlockX = blockX;
				var lookedBlockY = blockY;
				var lookedBlockZ = blockZ;
				if (render && render.pickAt) {
					var bPos = new Vector(blockX, blockY, blockZ);
					var centerX = render.canvas ? render.canvas.width / 2 : 0;
					var centerY = render.canvas ? render.canvas.height / 2 : 0;
					var pickedBlock = render.pickAt(
						new Vector(blockX - 4, Math.max(0, blockY - 2), blockZ - 4),
						new Vector(blockX + 4, Math.min(world.sy - 1, blockY + 2), blockZ + 4),
						centerX, centerY
					);
					if (pickedBlock && pickedBlock != false) {
						lookedBlock = world.getBlock(pickedBlock.x, pickedBlock.y, pickedBlock.z);
						lookedBlockX = pickedBlock.x;
						lookedBlockY = pickedBlock.y;
						lookedBlockZ = pickedBlock.z;
					}
				}
				
				// Usar el bloque que el jugador estÃ¡ mirando si estÃ¡ disponible, sino el bloque donde estÃ¡ parado
				var displayBlock = lookedBlock || block;
				var displayBlockX = lookedBlock ? lookedBlockX : blockX;
				var displayBlockY = lookedBlock ? lookedBlockY : blockY;
				var displayBlockZ = lookedBlock ? lookedBlockZ : blockZ;
				
				// Obtener nombre del bloque
				var blockName = 'AIR';
				if (displayBlock && displayBlock != BLOCK.AIR) {
					// Buscar el nombre del bloque comparando con los objetos BLOCK
					for (var key in BLOCK) {
						if (BLOCK[key] === displayBlock && typeof BLOCK[key] === 'object' && BLOCK[key].id !== undefined) {
							blockName = key;
							break;
						}
					}
					if (blockName === 'AIR') {
						blockName = 'UNKNOWN';
					}
				}
				
				// Calcular direcciÃ³n (yaw en radianes, 0 = Norte, PI/2 = Este, PI = Sur, 3*PI/2 = Oeste)
				var yaw = angles[1];
				// Normalizar yaw a 0-2*PI
				while (yaw < 0) yaw += 2 * Math.PI;
				while (yaw >= 2 * Math.PI) yaw -= 2 * Math.PI;
				
				var direction = '';
				var yawDegrees = (yaw * 180 / Math.PI) % 360;
				if (yawDegrees < 0) yawDegrees += 360;
				
				// Determinar direcciÃ³n cardinal
				if (yawDegrees >= 337.5 || yawDegrees < 22.5) direction = 'Norte';
				else if (yawDegrees >= 22.5 && yawDegrees < 67.5) direction = 'Noreste';
				else if (yawDegrees >= 67.5 && yawDegrees < 112.5) direction = 'Este';
				else if (yawDegrees >= 112.5 && yawDegrees < 157.5) direction = 'Sureste';
				else if (yawDegrees >= 157.5 && yawDegrees < 202.5) direction = 'Sur';
				else if (yawDegrees >= 202.5 && yawDegrees < 247.5) direction = 'Suroeste';
				else if (yawDegrees >= 247.5 && yawDegrees < 292.5) direction = 'Oeste';
				else if (yawDegrees >= 292.5 && yawDegrees < 337.5) direction = 'Noroeste';
				
				var debugHTML = '<div style="background: rgba(0,0,0,0.5); padding: 8px; border: 1px solid #00ff00;">';
				debugHTML += '<div><strong>Minecraft Web Edition - Debug (F3)</strong></div>';
				if (player.spectatorMode) {
					debugHTML += '<div style="color: #ffaa00; font-weight: bold; margin-top: 4px;">âš¡ MODO ESPECTADOR (F4 para desactivar)</div>';
				}
				debugHTML += '<div style="margin-top: 8px;">';
				debugHTML += '<div>PosiciÃ³n: X: ' + pos.x.toFixed(2) + ' Y: ' + pos.y.toFixed(2) + ' Z: ' + pos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Ojos: X: ' + eyePos.x.toFixed(2) + ' Y: ' + eyePos.y.toFixed(2) + ' Z: ' + eyePos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Bloque: X: ' + displayBlockX + ' Y: ' + displayBlockY + ' Z: ' + displayBlockZ + ' (' + blockName + ')</div>';
				debugHTML += '<div>DirecciÃ³n: ' + direction + ' (' + yawDegrees.toFixed(1) + 'Â°)</div>';
				debugHTML += '<div>Pitch: ' + (angles[0] * 180 / Math.PI).toFixed(1) + 'Â°</div>';
				
				// InformaciÃ³n de chunks si C+F3 estÃ¡ activo
				if (debugChunksEnabled) {
					// Ejes: X y Z = horizontal, Y = vertical (altura)
					var chunkX = Math.floor(pos.x / render.chunkSize);
					var chunkZ = Math.floor(pos.z / render.chunkSize); // Z es horizontal
					var chunkY = 0; // Siempre 0 porque solo hay un chunk vertical (cubre toda la altura Y)
					
					debugHTML += '<div style="margin-top: 8px; border-top: 1px solid #00ff00; padding-top: 8px;">';
					debugHTML += '<div><strong>Chunk Info (C+F3)</strong></div>';
					debugHTML += '<div>Chunk actual: [' + chunkX + ', ' + chunkY + ', ' + chunkZ + ']</div>';
					debugHTML += '<div>TamaÃ±o chunk: ' + render.chunkSize + 'x' + render.chunkSize + 'x' + render.chunkSizeY + ' (X, Z, Y)</div>';
					
					// Chunks alrededor
					debugHTML += '<div style="margin-top: 4px;">Chunks cargados: ';
					if (render.loadedChunks) {
						debugHTML += render.loadedChunks.size || 0;
					} else {
						debugHTML += '0';
					}
					debugHTML += '</div>';
					
					// Chunks cercanos
					debugHTML += '<div style="margin-top: 4px;">Chunks cercanos:</div>';
					var nearbyChunks = [];
					for (var dx = -1; dx <= 1; dx++) {
						for (var dy = -1; dy <= 1; dy++) {
							var cx = chunkX + dx;
							var cy = chunkY + dy;
							var cz = 0;
							var key = render.getChunkKey ? render.getChunkKey(cx, cy, cz) : (cx + '|' + cy + '|' + cz);
							var chunk = render.chunkLookup && render.chunkLookup[key];
							var loaded = chunk && chunk.loaded;
							nearbyChunks.push('[' + cx + ',' + cy + ',' + cz + ']' + (loaded ? 'âœ“' : 'âœ—'));
						}
					}
					debugHTML += '<div style="font-size: 10px;">' + nearbyChunks.join(' ') + '</div>';
					debugHTML += '</div>';
				}
				
				debugHTML += '</div>';
				debugHTML += '</div>';
				
				document.getElementById('debugInfo').innerHTML = debugHTML;
			}
			
			// Function to pause the game
			function pauseGame() {
				paused = true;
				document.getElementById('pauseOverlay').style.display = 'block';
				document.getElementById('pauseMenu').style.display = 'flex';
				document.getElementById('crosshair').style.display = 'none';
				document.getElementById('cursor').style.display = 'block';
				if ( player ) {
					player.pointerLocked = false;
					player.dragging = false;
					// Reset lastUpdate when pausing to prevent large delta on resume
					player.lastUpdate = new Date().getTime();
				}
				// Mostrar botÃ³n VR en el menÃº de pausa
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			}

			// Function to resume the game
			function resumeGame() {
				paused = false;
				document.getElementById('pauseOverlay').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				// Ocultar botÃ³n VR al reanudar el juego
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'none';
				}
				
				// Reset lastFrameTime BEFORE requesting pointer lock to prevent huge delta
				// This prevents the game from trying to catch up with all the paused time
				lastFrameTime = performance.now();
				
				// Reset FPS tracking when resuming
				lastTime = performance.now();
				frameCount = 0;
				
				// Reset player's lastUpdate to prevent large delta when resuming
				// This prevents the player from falling through the world
				if ( player && player.lastUpdate ) {
					player.lastUpdate = new Date().getTime();
				}
				
				// Reset renderer's updateChunks state to prevent immediate massive update
				if ( render ) {
					render._updateChunksState = null;
					render._loadIndex = 0;
					render._unloadIndex = 0;
					// Delay first updateChunks call by setting frame count high
					// This gives the game a few frames to stabilize before chunk updates
					render._updateChunksFrameCount = 10; // Wait 10 frames before first update
				}
				
				// Request pointer lock after a small delay to ensure state is reset
				if ( player && player.canvas ) {
					setTimeout(function() {
						if (player && player.canvas && !paused) {
							player.canvas.requestPointerLock();
						}
					}, 50); // Small delay to let state settle
				}
			}

			function playClickSound() { // detects when the player touches a button in the gui
                clickSound.currentTime = 0;
                clickSound.play().catch(function(e) { console.log('Audio play failed:', e); });
            }

			// Pause menu event handlers
			document.getElementById('resumeButton').onclick = function() {
				resumeGame();
			};

			document.getElementById('pauseSettingsButton').onclick = function() {
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'flex';
				// Mantener botÃ³n VR visible en el menÃº de ajustes
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			};

			document.getElementById('exitButton').onclick = async function() {
				console.log("Saving game data before exit...");
				
				// Guardar todos los chunks modificados (esperar a que termine)
				if ( world && world.saveAllLoadedChunks ) {
					try {
						var savedChunks = await world.saveAllLoadedChunks();
						console.log("Saved", savedChunks, "modified chunks");
					} catch (e) {
						console.warn("Error saving chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Player data saved successfully");
					} catch (e) {
						console.warn("Could not save player data:", e);
					}
				}
				
				// Redirigir inmediatamente (los datos ya estÃ¡n guardados)
				window.location.href = 'index.html';
			};

			// Pause settings menu event handlers
			document.getElementById('pauseSettingsBackButton').onclick = function() {
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'flex';
				// Mantener botÃ³n VR visible al volver al menÃº de pausa
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			};

			pauseRenderDistanceSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseRenderDistanceValue.textContent = value;
				localStorage.setItem('renderDistance', value);
				if ( render ) render.setRenderDistance(value);
			};

			pauseGuiScaleSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseGuiScaleValue.textContent = value;
				setGuiScale(value);
			};

			pauseFpsToggle.onchange = function() {
				localStorage.setItem('showFPS', pauseFpsToggle.checked);
				if (pauseFpsToggle.checked) {
					document.getElementById('fpsDisplay').style.display = 'block';
				} else {
					document.getElementById('fpsDisplay').style.display = 'none';
				}
			};
			
			// FunciÃ³n para guardar todos los datos (chunks y jugador)
			async function saveAllGameData() {
				// Guardar chunks modificados
				if ( world && world.saveAllLoadedChunks ) {
					try {
						await world.saveAllLoadedChunks();
						console.log("Auto-saved chunks");
					} catch (e) {
						console.warn("Could not auto-save chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Auto-saved player data");
					} catch (e) {
						console.warn("Could not auto-save player data:", e);
					}
				}
			}
			
			// Auto-guardar datos del jugador cada 60 segundos (solo posiciÃ³n/inventario, NO chunks)
			// Los chunks se mantienen en RAM y solo se guardan al salir del mundo
			var autoSaveInterval = setInterval(function() {
				if ( !paused && world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
					} catch (e) {
						console.warn("Auto-save player data failed:", e);
					}
				}
			}, 60000);
			
			// Guardar chunks cuando se cierra la pestaÃ±a o el navegador
			window.addEventListener('beforeunload', function() {
				// Usar localStorage como backup rÃ¡pido para datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Could not backup player data:", e);
					}
				}
				
				// Intentar guardar chunks (puede no completarse si se cierra muy rÃ¡pido)
				if ( world && world.saveAllLoadedChunks ) {
					world.saveAllLoadedChunks();
				}
			});
			
			// Guardar cuando la pestaÃ±a se oculta (Ãºtil para mÃ³viles)
			document.addEventListener('visibilitychange', function() {
				if ( document.hidden && world && world.worldId && player ) {
					// Solo guardar datos del jugador (rÃ¡pido)
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Visibility save failed:", e);
					}
				}
			});

			// NOTA: El sistema de drag anterior ha sido reemplazado por el sistema de look de Minecraft PE
			// que estÃ¡ integrado en setupMobileControls() y funciona mejor para mÃ³viles
		</script>
	</body>
</html lang="es">
