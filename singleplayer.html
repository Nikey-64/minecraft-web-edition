<!DOCTYPE HTML>
<html lang="es">
	<head>
		<title>minecraft web edition 0.0.0-B</title>
		
		<!-- Character encoding -->
		<meta content="text/html" charset="UTF-8">
		<!-- Favicon -->
		<link rel="icon" href="media/favicon.png">

		<!-- Stylesheet -->
		<link href="style/main.css" rel="stylesheet" type="text/css">
		
		<!-- Modules -->
		<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
		<script src="js/blocks.js" type="text/javascript"></script>
		<script src="js/helpers.js" type="text/javascript"></script>
		<script src="js/items.js" type="text/javascript"></script>
		<script src="js/entities.js" type="text/javascript"></script>
		<script src="js/crafting.js" type="text/javascript"></script>
		<script src="js/worldManager.js" type="text/javascript"></script>
		<script src="js/world.js" type="text/javascript"></script>
		<script src="js/render.js" type="text/javascript"></script>
		<script src="js/physics.js" type="text/javascript"></script>
		<script src="js/player.js" type="text/javascript"></script>
		<script src="js/vr.js" type="text/javascript"></script>
	</head>
	
	<body oncontextmenu="return false">
		<!-- Loads the gui audio for buttons -->
		<audio id="clickSound" src="sounds/gui/Click_stereo.ogg.mp3" preload="auto"></audio>
		<!-- Render surface -->
		<canvas id="renderSurface"></canvas>

		<img id="cursor" class="cursor" src="media/gui/cursor.png" />
		<img id="crosshair" class="crosshair" src="media/gui/cursor.png" />

		<!-- VR Button -->
		<button id="vr-button" class="vr-button">
			游꿡 Verificando VR...
		</button>

		<!-- FPS Display -->
		<div id="fpsDisplay" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Minecraftia; display: none;"></div>

		<!-- Debug Overlay (F3) -->
		<div id="debugOverlay" style="position: absolute; top: 10px; left: 10px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 1000;">
			<div id="debugInfo"></div>
		</div>
		
		
		<!-- Item Title Display (shows item name when switching hotbar slots) -->
		<div id="itemTitleDisplay" style="position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%) scale(var(--gui-scale)); transform-origin: center bottom; color: white; font-family: 'Minecraftia', monospace; font-size: 11px; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); pointer-events: none; z-index: 1002; opacity: 0; transition: opacity 0.3s ease-in-out; text-align: center;">
			<div id="itemTitleText"></div>
		</div>

		<!-- Dragged Item Cursor (follows mouse when dragging items) -->
		<div id="draggedItemCursor" style="position: fixed; pointer-events: none; z-index: 2000; display: none; image-rendering: pixelated;">
			<div id="draggedItemThumbnail" style="width: 32px; height: 32px;"></div>
			<div id="draggedItemCount" class="item-count" style="position: absolute; bottom: 0; right: 0; font-size: 12px;"></div>
		</div>

		<!-- Health Icons (Survival mode only) - Left side of hotbar -->
		<div id="healthIcons" class="health-icons" style="display: none;"></div>

		<!-- Hunger Icons (Survival mode only) - Right side of hotbar -->
		<div id="hungerIcons" class="hunger-icons" style="display: none;"></div>

		<!-- Creative Inventory Button (only visible in creative mode) -->
		<button id="creativeInventoryButton" class="creative-inventory-button" style="display: none;">
			<img src="media/item/chest.png" alt="Creative Inventory" />
		</button>

		<!-- Hotbar -->
		<div id="hotbar" class="hotbar">
			<div class="hotbar-slot" data-slot="0"></div>
			<div class="hotbar-slot" data-slot="1"></div>
			<div class="hotbar-slot" data-slot="2"></div>
			<div class="hotbar-slot" data-slot="3"></div>
			<div class="hotbar-slot" data-slot="4"></div>
			<div class="hotbar-slot" data-slot="5"></div>
			<div class="hotbar-slot" data-slot="6"></div>
			<div class="hotbar-slot" data-slot="7"></div>
			<div class="hotbar-slot" data-slot="8"></div>
		</div>

		<!-- Creative Inventory Menu -->
		<div id="creativeInventory" class="creative-inventory" style="display: none;">
			<div class="creative-inventory-overlay"></div>
			<div class="creative-inventory-container">
				<div class="creative-inventory-header">
					<h2>Inventario Creativo</h2>
					<button class="creative-inventory-close" id="creativeInventoryCloseButton">칑</button>
				</div>
				<div id="creativeInventoryGrid" class="creative-inventory-grid">
					<!-- Blocks will be populated here -->
				</div>
			</div>
		</div>

		<!-- Inventory -->
		<div id="inventory" class="inventory" style="display: none;">
			<div id="inventoryOverlay" class="inventory-overlay"></div>
			<div class="inventory-container">
				<!-- Armor slots (top left) -->
				<div class="inventory-armor">
					<div class="inventory-slot armor-slot" data-type="helmet"></div>
					<div class="inventory-slot armor-slot" data-type="chestplate"></div>
					<div class="inventory-slot armor-slot" data-type="leggings"></div>
					<div class="inventory-slot armor-slot" data-type="boots"></div>
				</div>
				
				<!-- Player model area (left of armor) -->
				<div class="inventory-player-model">
					<canvas id="inventoryPlayerCanvas" class="inventory-player-canvas"></canvas>
				</div>
				
				<!-- Crafting grid 2x2 (top right, like vanilla Minecraft) -->
				<div class="inventory-crafting-area">
					<div class="inventory-crafting-grid">
						<div class="inventory-crafting-slot" data-craft-inv="0"></div>
						<div class="inventory-crafting-slot" data-craft-inv="1"></div>
						<div class="inventory-crafting-slot" data-craft-inv="2"></div>
						<div class="inventory-crafting-slot" data-craft-inv="3"></div>
					</div>
					<div class="inventory-crafting-arrow"></div>
					<div class="inventory-crafting-result">
						<div class="inventory-crafting-result-slot" id="inventoryCraftingResult"></div>
					</div>
				</div>
				
				<!-- Main inventory grid (center) -->
				<div class="inventory-grid">
					<!-- 9 rows x 9 columns = 36 slots -->
				</div>
				
				<!-- Inventory hotbar (bottom) -->
				<div class="inventory-hotbar">
					<div class="inventory-slot" data-inv-slot="0"></div>
					<div class="inventory-slot" data-inv-slot="1"></div>
					<div class="inventory-slot" data-inv-slot="2"></div>
					<div class="inventory-slot" data-inv-slot="3"></div>
					<div class="inventory-slot" data-inv-slot="4"></div>
					<div class="inventory-slot" data-inv-slot="5"></div>
					<div class="inventory-slot" data-inv-slot="6"></div>
					<div class="inventory-slot" data-inv-slot="7"></div>
					<div class="inventory-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Crafting Table GUI -->
		<div id="craftingTable" class="crafting-table" style="display: none;">
			<div id="craftingTableOverlay" class="crafting-table-overlay"></div>
			<div class="crafting-table-container">
				<!-- Crafting grid 3x3 -->
				<div class="crafting-table-grid">
					<div class="crafting-table-slot" data-craft-table="0"></div>
					<div class="crafting-table-slot" data-craft-table="1"></div>
					<div class="crafting-table-slot" data-craft-table="2"></div>
					<div class="crafting-table-slot" data-craft-table="3"></div>
					<div class="crafting-table-slot" data-craft-table="4"></div>
					<div class="crafting-table-slot" data-craft-table="5"></div>
					<div class="crafting-table-slot" data-craft-table="6"></div>
					<div class="crafting-table-slot" data-craft-table="7"></div>
					<div class="crafting-table-slot" data-craft-table="8"></div>
				</div>
				
				<!-- Crafting arrow -->
				<div class="crafting-table-arrow"></div>
				
				<!-- Crafting output -->
				<div class="crafting-table-output">
					<div class="crafting-table-result" data-craft-table="output"></div>
				</div>
				
				<!-- Player inventory (below crafting area) -->
				<div class="crafting-table-inventory-grid">
					<!-- 3 rows x 9 columns -->
				</div>
				
				<!-- Hotbar (bottom) -->
				<div class="crafting-table-hotbar">
					<div class="crafting-table-slot" data-inv-slot="0"></div>
					<div class="crafting-table-slot" data-inv-slot="1"></div>
					<div class="crafting-table-slot" data-inv-slot="2"></div>
					<div class="crafting-table-slot" data-inv-slot="3"></div>
					<div class="crafting-table-slot" data-inv-slot="4"></div>
					<div class="crafting-table-slot" data-inv-slot="5"></div>
					<div class="crafting-table-slot" data-inv-slot="6"></div>
					<div class="crafting-table-slot" data-inv-slot="7"></div>
					<div class="crafting-table-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Pause overlay -->
		<div id="pauseOverlay" class="gui-overlay" style="display: none;"></div>

		<!-- World Selection Menu (shown before game starts) -->
		<div id="worldSelectionMenu" class="gui" style="display: flex;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Seleccionar Mundo</h2>
				</div>
				<div class="world-list-container">
					<div id="worldList" class="world-list">
						<!-- Worlds will be populated here -->
						<div class="world-empty">Cargando mundos...</div>
					</div>
				</div>
				<div class="world-selection-actions">
					<button id="createWorldButton" class="button">Crear Nuevo Mundo</button>
					<button id="refreshWorldsButton" class="button">Actualizar</button>
				</div>
			</div>
		</div>

		<!-- Create World Menu -->
		<div id="createWorldMenu" class="gui" style="display: none;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Crear Nuevo Mundo</h2>
				</div>
				<div class="world-form">
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Nombre del Mundo:</label>
						<input type="text" id="worldNameInput" class="world-input" placeholder="Nuevo Mundo" maxlength="32" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Tama침o del Mundo:</label>
						<select id="worldSizeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="64">Peque침o (64x64x64)</option>
							<option value="128" selected>Mediano (128x128x128)</option>
							<option value="256">Grande (256x256x256)</option>
						</select>
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Altura del Terreno Plano:</label>
						<input type="number" id="flatHeightInput" class="world-input" value="4" min="1" max="64" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Modo de Juego:</label>
						<select id="worldGameModeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="0" selected>Supervivencia</option>
							<option value="1">Creativo</option>
							<option value="2">Espectador</option>
						</select>
					</div>
					<div class="world-form-actions">
						<button id="createWorldConfirmButton" class="button">Crear Mundo</button>
						<button id="createWorldCancelButton" class="button">Cancelar</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Pause menu -->
		<div id="pauseMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button id="resumeButton" class="button">Volver al juego</button>
				<button id="pauseSettingsButton" class="button">Ajustes</button>
				<button id="exitButton" class="button" details="guardar-y-salir">Salir al menu principal</button>
			</div>
		</div>

		<!-- Pause settings menu -->
		<div id="pauseSettingsMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button class="button" id="pauseSettingsBackButton">Volver</button>
				<div style="margin: 20px 0;">
					<label for="pauseRenderDistanceSlider" style="color: white; font-family: Minecraftia;">Render Distance: <span id="pauseRenderDistanceValue">8</span> chunks</label><br>
					<input type="range" id="pauseRenderDistanceSlider" min="4" max="16" value="8" step="1" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label for="pauseGuiScaleSlider" style="color: white; font-family: Minecraftia;">GUI Scale: <span id="pauseGuiScaleValue">200</span>%</label><br>
					<input type="range" id="pauseGuiScaleSlider" min="100" max="200" value="200" step="10" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label style="color: white; font-family: Minecraftia;">
						<input type="checkbox" id="pauseFpsToggle" style="margin-right: 10px;">Mostrar FPS
					</label>
				</div>
			</div>
		</div>
		
		<!-- Initialisation code -->
		<script type="text/javascript">
			
			const DEFAULT_SEED_NAME = "flat_default_seed";
			const SEED_API_ENDPOINT = "api/seeds.php";
			const ACTIVE_SEED_KEY = "activeSeedName";
			const SEED_SELECTION_KEY = "selectedSeed";

			var world;
			var render;
			var physics;
			var player;

			// Game state
			var paused = false;
			var gameLoopInterval;
			
			// Debug state
			var debugEnabled = false;
			var debugChunksEnabled = false;

			// FPS tracking
			var fps = 0;
			var lastTime = performance.now();
			var frameCount = 0;
			var lastFrameTime = null; // Will be initialized in startGameLoop

			// Performance profiling
			var performanceStats = {
				physics: { total: 0, count: 0, max: 0 },
				playerUpdate: { total: 0, count: 0, max: 0 },
				buildChunks: { total: 0, count: 0, max: 0 },
				updateChunks: { total: 0, count: 0, max: 0 },
				setCamera: { total: 0, count: 0, max: 0 },
				draw: { total: 0, count: 0, max: 0 },
				total: { total: 0, count: 0, max: 0 }
			};

			function measureTime(statName, fn) {
				var start = performance.now();
				var result = fn();
				var elapsed = performance.now() - start;
				var stat = performanceStats[statName];
				if (stat) {
					stat.total += elapsed;
					stat.count++;
					if (elapsed > stat.max) stat.max = elapsed;
				}
				return result;
			}

			// Make performance stats available globally for debugging
			window.performanceStats = performanceStats;

			function logPerformanceStats() {
				if (performanceStats.total.count === 0) return;
				console.log("=== Performance Stats (last second) ===");
				for (var key in performanceStats) {
					var stat = performanceStats[key];
					if (stat.count > 0) {
						var avg = stat.total / stat.count;
						console.log(key + ": avg=" + avg.toFixed(2) + "ms, max=" + stat.max.toFixed(2) + "ms, calls=" + stat.count);
					}
				}
				// Reset stats
				for (var key in performanceStats) {
					performanceStats[key] = { total: 0, count: 0, max: 0 };
				}
			}

			var pauseRenderDistanceSlider = document.getElementById('pauseRenderDistanceSlider');
			var pauseRenderDistanceValue = document.getElementById('pauseRenderDistanceValue');
			var pauseGuiScaleSlider = document.getElementById('pauseGuiScaleSlider');
			var pauseGuiScaleValue = document.getElementById('pauseGuiScaleValue');
			var pauseFpsToggle = document.getElementById('pauseFpsToggle');

			// Initialize world manager and show selection menu
			initWorldManager();

			async function initWorldManager() {
				// Hide game canvas when showing world selection
				var canvas = document.getElementById("renderSurface");
				if ( canvas ) {
					canvas.style.display = "none";
				}
				
				// Initialize world manager
				try {
					await initializeWorldManager();
					await loadWorldsList();
					setupWorldManagerUI();
				} catch ( error ) {
					console.warn( "Failed to initialize world manager:", error );
					// Show error message
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar mundos. Usando mundo por defecto.</div>';
					}
				}
			}

			async function loadWorldsList() {
				try {
					var worlds = await getAllWorlds();
					var worldList = document.getElementById("worldList");
					if ( !worldList ) return;
					
					if ( worlds.length === 0 ) {
						worldList.innerHTML = '<div class="world-empty">No hay mundos. Crea uno nuevo para comenzar.</div>';
						return;
					}
					
					worldList.innerHTML = "";
					for ( var i = 0; i < worlds.length; i++ ) {
						var worldData = worlds[i];
						var worldItem = createWorldItem( worldData );
						worldList.appendChild( worldItem );
					}
				} catch ( error ) {
					console.error( "Failed to load worlds list:", error );
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar la lista de mundos.</div>';
					}
				}
			}

			function createWorldItem( worldData ) {
				var item = document.createElement("div");
				item.className = "world-item";
				item.setAttribute("data-world-id", worldData.id);
				
				var gameModeNames = { 0: "Supervivencia", 1: "Creativo", 2: "Espectador" };
				var gameModeName = gameModeNames[worldData.gameMode] || "Desconocido";
				
				var createdDate = new Date(worldData.created);
				var dateStr = createdDate.toLocaleDateString();
				
				item.innerHTML = '<div class="world-item-info">' +
					'<div class="world-item-name">' + escapeHtml(worldData.name) + '</div>' +
					'<div class="world-item-details">' + 
						gameModeName + ' | ' + 
						worldData.sizeX + 'x' + worldData.sizeY + 'x' + worldData.sizeZ + ' | ' +
						dateStr +
					'</div>' +
				'</div>' +
				'<div class="world-item-actions">' +
					'<button class="button-small" onclick="playWorld(' + worldData.id + ')">Jugar</button>' +
					'<button class="button-small" onclick="deleteWorld(' + worldData.id + ', this)">Eliminar</button>' +
				'</div>';
				
				// Click on item to play
				item.onclick = function(e) {
					if ( e.target.tagName !== "BUTTON" ) {
						playWorld( worldData.id );
					}
				};
				
				return item;
			}

			function escapeHtml(text) {
				var div = document.createElement("div");
				div.textContent = text;
				return div.innerHTML;
			}

			function setupWorldManagerUI() {
				// Hide hotbar when world selection menu is visible (initial state)
				var worldSelectionMenu = document.getElementById("worldSelectionMenu");
				if (worldSelectionMenu && worldSelectionMenu.style.display === "flex") {
					document.body.classList.add("world-selection-active");
				}
				
				// Inicializar VR Manager si est치 disponible (en la pantalla de selecci칩n de mundos)
				if (typeof VRManager !== "undefined") {
					console.log("VR: Inicializando VRManager en pantalla de selecci칩n de mundos...");
					// Crear un renderer temporal solo para VR (no se usar치 hasta que se cargue un mundo)
					var tempRenderer = { vrManager: null };
					tempRenderer.vrManager = new VRManager(tempRenderer);
					tempRenderer.vrManager.createVRButton("body");
					// Guardar referencia global para usar despu칠s
					window.tempVRManager = tempRenderer.vrManager;
				}
				
				// Create world button
				var createButton = document.getElementById("createWorldButton");
				if ( createButton ) {
					createButton.onclick = function() {
						document.getElementById("worldSelectionMenu").style.display = "none";
						document.getElementById("createWorldMenu").style.display = "flex";
						// Remove class to show hotbar when leaving world selection
						document.body.classList.remove("world-selection-active");
					};
				}
				
				// Refresh worlds button
				var refreshButton = document.getElementById("refreshWorldsButton");
				if ( refreshButton ) {
					refreshButton.onclick = function() {
						loadWorldsList();
					};
				}
				
				// Create world form
				var createConfirmButton = document.getElementById("createWorldConfirmButton");
				if ( createConfirmButton ) {
					createConfirmButton.onclick = async function() {
						var name = document.getElementById("worldNameInput").value.trim() || "Nuevo Mundo";
						var size = parseInt(document.getElementById("worldSizeSelect").value) || 128;
						var flatHeight = parseInt(document.getElementById("flatHeightInput").value) || 4;
						var gameMode = parseInt(document.getElementById("worldGameModeSelect").value) || 0;
						
						try {
							var worldData = await createNewWorld( name, size, size, size, flatHeight, gameMode );
							
							// Crear instancia temporal del mundo para generar y guardar todos los chunks base
							var tempWorld = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
							tempWorld.worldId = worldData.id;
							tempWorld.flatHeight = worldData.flatHeight || 4;
							tempWorld.spawn = new Vector( worldData.spawn.x, worldData.spawn.y, worldData.spawn.z );
							
							// Generar y guardar todos los chunks base en IndexedDB
							console.log("Generating and saving all base chunks for new world...");
							await tempWorld.generateAndSaveAllChunks();
							console.log("World created and all chunks saved!");
							
							await loadWorldsList();
							document.getElementById("createWorldMenu").style.display = "none";
							document.getElementById("worldSelectionMenu").style.display = "flex";
							// Add class to hide hotbar when showing world selection
							document.body.classList.add("world-selection-active");
							// Reset form
							document.getElementById("worldNameInput").value = "";
							document.getElementById("worldSizeSelect").value = "128";
							document.getElementById("flatHeightInput").value = "4";
							document.getElementById("worldGameModeSelect").value = "0";
						} catch ( error ) {
							console.error( "Failed to create world:", error );
							alert( "Error al crear el mundo: " + error.message );
						}
					};
				}
				
				var createCancelButton = document.getElementById("createWorldCancelButton");
				if ( createCancelButton ) {
					createCancelButton.onclick = function() {
						document.getElementById("createWorldMenu").style.display = "none";
						document.getElementById("worldSelectionMenu").style.display = "flex";
						// Add class to hide hotbar when showing world selection
						document.body.classList.add("world-selection-active");
						// Reset form
						document.getElementById("worldNameInput").value = "";
						document.getElementById("worldSizeSelect").value = "128";
						document.getElementById("flatHeightInput").value = "4";
						document.getElementById("worldGameModeSelect").value = "0";
					};
				}
			}

			// Global functions for world actions
			window.playWorld = async function(worldId) {
				try {
					var worldData = await getWorldById(worldId);
					world = await loadWorldFromData(worldData);
					
					// Hide world selection menu
					document.getElementById("worldSelectionMenu").style.display = "none";
					document.getElementById("createWorldMenu").style.display = "none";
					// Remove class to show hotbar when leaving world selection
					document.body.classList.remove("world-selection-active");
					
					// Show game canvas
					var canvas = document.getElementById("renderSurface");
					if ( canvas ) {
						canvas.style.display = "block";
					}
					
					// Start game
					setupGameSystems();
					initialisePauseSettings();
					
					// Ocultar bot칩n VR durante el gameplay
					var vrButton = document.getElementById('vr-button');
					if (vrButton) {
						vrButton.style.display = 'none';
					}
					
					// Load player data after player is created
					try {
						var playerData = await loadPlayerDataFromWorld(worldId);
						
						// If no data in IndexedDB, try localStorage backup
						if (!playerData) {
							var backupData = localStorage.getItem('player_backup_' + worldId);
							if (backupData) {
								try {
									playerData = JSON.parse(backupData);
									console.log("Loaded player data from backup");
									// Clear backup after loading
									localStorage.removeItem('player_backup_' + worldId);
								} catch (e) {
									console.warn("Could not parse backup player data:", e);
								}
							}
						}
						
						if (playerData && player) {
							player.loadPlayerData(playerData);
							console.log("Player data loaded successfully");
						}
					} catch (e) {
						console.warn("Could not load player data:", e);
					}
					
					startGameLoop();
				} catch ( error ) {
					console.error( "Failed to load world:", error );
					alert( "Error al cargar el mundo: " + error.message );
				}
			};

			window.deleteWorld = async function(worldId, buttonElement) {
				if ( !confirm( "쮼st치s seguro de que quieres eliminar este mundo? Esta acci칩n no se puede deshacer." ) ) {
					return;
				}
				
				try {
					await deleteWorldById(worldId);
					// Remove from list
					if ( buttonElement ) {
						var worldItem = buttonElement.closest(".world-item");
						if ( worldItem ) {
							worldItem.remove();
						}
					}
					// Reload list
					await loadWorldsList();
				} catch ( error ) {
					console.error( "Failed to delete world:", error );
					alert( "Error al eliminar el mundo: " + error.message );
				}
			};
			
			// loadWorldFromData( worldData )
			//
			// Loads a world from world metadata.
			
			async function loadWorldFromData( worldData ) {
				var w = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
				w.worldId = worldData.id;
				w.flatHeight = worldData.flatHeight || 4; // Store flatHeight for chunk generation
				w.gameMode = worldData.gameMode !== undefined ? worldData.gameMode : 0; // Store gameMode (default: Survival)
				
				// Set spawn position
				if ( worldData.spawn ) {
					w.spawn = new Vector( worldData.spawn.x, worldData.spawn.y, worldData.spawn.z );
				} else {
					w.spawn = new Vector( worldData.sizeX / 2 + 0.5, worldData.flatHeight + 1, worldData.sizeZ / 2 + 0.5 );
				}
				
				// Don't generate the entire world - chunks will be loaded on demand
				// This prevents loading everything into RAM
				
				return w;
			}

			function fetchSeedDefinition( seedName ) {
				return fetch( SEED_API_ENDPOINT + "?name=" + encodeURIComponent( seedName ), { cache: "no-store" } )
					.then( function( response ) {
						if ( !response.ok ) {
							throw new Error( "Seed API devolvi칩 " + response.status );
						}
						return response.json();
					} );
			}

			function buildWorldFromSeed( seedDefinition, seedName ) { // this is an example of beta world, this should be removed
				var sx = seedDefinition.sx || 255;
				var sy = seedDefinition.sy || 255;
				var sz = seedDefinition.sz || 255;
				var chunkSize = seedDefinition.chunkSize || 8;
				var chunkSizeY = 256; // Chunks de 8x8x256 (X, Z, Y) para optimizar aire - Y es vertical (altura)
				var w = new World( sx, sy, sz );
				if ( w.setChunking ) w.setChunking( chunkSize, chunkSizeY );

				if ( Array.isArray( seedDefinition.chunks ) && seedDefinition.chunks.length ) {
					preloadSeedChunks( w, seedDefinition.chunks, seedName );
				} else if ( typeof seedDefinition.blocks === "string" && seedDefinition.blocks.length ) {
					w.createFromString( seedDefinition.blocks );
				} else if ( typeof seedDefinition.height === "number" ) {
					w.createFlatWorld( seedDefinition.height );
				} else {
					w.createFlatWorld( 256 );
				}

				var spawn = seedDefinition.spawn || [ sx / 2 + 0.5, sy / 2 + 0.5, 64 ];
				w.spawn = new Vector( spawn[0], spawn[1], spawn[2] );
				return w;
			}

			function preloadSeedChunks( worldInstance, chunks, seedName ) {
				if ( typeof localStorage === "undefined" ) return;

				var previousSeed = localStorage.getItem( ACTIVE_SEED_KEY );
				if ( previousSeed !== seedName ) {
					clearStoredChunkCache( worldInstance.chunkStoragePrefix );
				}

				for ( var i = 0; i < chunks.length; i++ ) {
					var chunkDef = chunks[i];
					if ( typeof chunkDef.data !== "string" ) continue;
					var key = chunkDef.cx + "|" + chunkDef.cy + "|" + chunkDef.cz;
					try {
						localStorage.setItem( worldInstance.chunkStoragePrefix + key, chunkDef.data );
						if ( worldInstance.chunkStates ) worldInstance.chunkStates[key] = "stored";
					} catch ( e ) {
						console.warn( "No se pudo guardar el chunk " + key + " en localStorage.", e );
						break;
					}
				}

				localStorage.setItem( ACTIVE_SEED_KEY, seedName );
			}

			function clearStoredChunkCache( prefix ) {
				if ( typeof localStorage === "undefined" ) return;
				var keysToDelete = [];
				for ( var i = 0; i < localStorage.length; i++ ) {
					var key = localStorage.key( i );
					if ( key && key.indexOf( prefix ) === 0 ) keysToDelete.push( key );
				}
				for ( var k = 0; k < keysToDelete.length; k++ ) {
					localStorage.removeItem( keysToDelete[k] );
				}
			}

			function buildFallbackWorld() {
				var fallbackWorld = new World( 128, 128, 128 );
				fallbackWorld.createFlatWorld( 4 );
				return fallbackWorld;
			}

			function setupGameSystems() {
				render = new Renderer( "renderSurface" );
				render.setWorld( world, 8, 256 ); // Chunks de 8x8x256 para optimizar aire
				render.setPerspective( 60, 0.01, 200 );
				
				// Inicializar VR Manager si est치 disponible (usar el que ya se cre칩 en setupWorldManagerUI)
				console.log("VR: Verificando si VRManager est치 disponible...", typeof VRManager);
				if (typeof VRManager !== "undefined") {
					// Si ya existe un VRManager temporal, reutilizarlo y actualizar su renderer
					if (window.tempVRManager) {
						console.log("VR: Reutilizando VRManager existente...");
						window.tempVRManager.renderer = render;
						// Actualizar las matrices originales ahora que el renderer est치 completo
						if (render.projMatrix && render.viewMatrix) {
							window.tempVRManager.originalProjMatrix = render.projMatrix;
							window.tempVRManager.originalViewMatrix = render.viewMatrix;
						}
						render.vrManager = window.tempVRManager;
						window.tempVRManager = null; // Limpiar referencia temporal
					} else {
						console.log("VR: Creando nuevo VRManager...");
						render.vrManager = new VRManager(render);
						// El bot칩n ya deber칤a estar creado, solo actualizar la referencia
						var button = document.getElementById('vr-button');
						if (button && render.vrManager) {
							render.vrManager.vrButton = button;
						}
					}
				} else {
					console.warn("VR: VRManager no est치 definido. 쯉e carg칩 js/vr.js?");
				}

				physics = new Physics();
				physics.setWorld( world );
				// Agregar referencia a physics en el world para que el renderer pueda acceder
				world.physics = physics;

				player = new Player();
				player.setWorld( world );
				player.setPhysics( physics );
				player.setInputCanvas( "renderSurface" );
				player.initInventory();
				
				// Set game mode from world data
				if ( world.gameMode !== undefined ) {
					player.setGameMode( world.gameMode );
				}
				
				// Setup debug key handlers
				setupDebugKeys();
			}
			
			function setupDebugKeys() {
				// Interceptar eventos de teclado para F3, C+F3 y F4 (modo espectador)
				var originalOnKeyEvent = player.onKeyEvent;
				player.onKeyEvent = function(keyCode, down) {
					// Llamar al handler original
					originalOnKeyEvent.call(this, keyCode, down);
					
					// F3 key code = 114
					if (keyCode === 114) {
						if (down) {
							// Verificar si C est치 presionado
							if (this.keys['c'] || this.keys[67]) {
								debugChunksEnabled = !debugChunksEnabled;
								render.showChunkGrid = debugChunksEnabled;
							} else {
								debugEnabled = !debugEnabled;
								document.getElementById('debugOverlay').style.display = debugEnabled ? 'block' : 'none';
							}
						}
					}
					
					// F4 key code = 115 (Modo espectador)
					if (keyCode === 115 && down) {
						if (this.spectatorMode !== undefined) {
							this.spectatorMode = !this.spectatorMode;
							// Resetear velocidad al cambiar de modo
							this.velocity = new Vector( 0, 0, 0 );
							this.falling = false;
							// Forzar primera persona cuando se activa el modo espectador
							if (this.spectatorMode) {
								this.cameraMode = 1;
							}
							console.log('Modo espectador: ' + (this.spectatorMode ? 'ACTIVADO' : 'DESACTIVADO'));
						}
					}
					
					// F5 key code = 116 (Cambio de perspectiva) - manejado en player.js
				};
			}

			// Function to set GUI scale
			function setGuiScale(scale) {
				// scale is a percentage (100-300), convert to decimal (1.0-3.0)
				var scaleDecimal = scale / 100; // 100% = 1.0x, 200% = 2.0x, 300% = 3.0x
				document.documentElement.style.setProperty('--gui-scale', scaleDecimal);
				localStorage.setItem('guiScale', scale);
			}

			// Function to get GUI scale from localStorage or default
			function getGuiScale() {
				var savedScale = localStorage.getItem('guiScale');
				return savedScale ? parseInt(savedScale) : 200; // Default 200%
			}

			function initialisePauseSettings() {
				var savedRenderDistance = localStorage.getItem('renderDistance') || '8';
				pauseRenderDistanceSlider.value = savedRenderDistance;
				pauseRenderDistanceValue.textContent = savedRenderDistance;
				render.setRenderDistance(parseInt(savedRenderDistance));

				var savedGuiScale = getGuiScale();
				pauseGuiScaleSlider.value = savedGuiScale;
				pauseGuiScaleValue.textContent = savedGuiScale;
				setGuiScale(savedGuiScale);

				var savedShowFPS = localStorage.getItem('showFPS') || 'false';
				pauseFpsToggle.checked = savedShowFPS === 'true';
				if (savedShowFPS === 'true') {
					document.getElementById('fpsDisplay').style.display = 'block';
				}
			}

			// Setup Canvas 2D player model for inventory
			function setupInventoryPlayerModelCSS3D() {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) {
					// Try again after a short delay if element not ready
					setTimeout(setupInventoryPlayerModelCSS3D, 100);
					return;
				}
				
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Set canvas size - must match the container size exactly
				// Get the actual size of the container (accounts for GUI scale)
				var container = canvas.parentElement;
				if (container) {
					var rect = container.getBoundingClientRect();
					// Use the actual rendered size (after GUI scale)
					canvas.width = 52; // Base width in pixels (matches container)
					canvas.height = 70; // Base height in pixels (matches container)
					// The CSS will scale it, so we keep base size here
				} else {
					// Fallback to base size
					canvas.width = 52;
					canvas.height = 70;
				}
				
				var container = canvas.parentElement; // .inventory-player-model
				if (!container) return;
				
				// Prevent duplicate event listeners
				if (container._inventoryModelSetup) return;
				container._inventoryModelSetup = true;
				
				// Load player texture
				var playerImage = new Image();
				playerImage.onload = function() {
					// Store image for rendering
					canvas._playerTexture = playerImage;
					// Store ctx and canvas for later use
					canvas._ctx = ctx;
					
					// Ensure rotation state is initialized
					if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
					if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					
					// Initial render
					renderInventoryPlayerModel(ctx, canvas, canvas._modelYaw, canvas._modelPitch);
					
					// If inventory is already open, start render loop now that texture is loaded
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						// Initialize mouse position
						var container = canvas.parentElement;
						if (container && (canvas._lastMouseX === undefined || canvas._lastMouseX === null)) {
							var rect = container.getBoundingClientRect();
							canvas._lastMouseX = rect.left + rect.width / 2;
							canvas._lastMouseY = rect.top + rect.height / 2;
						}
						// Start render loop if not already running
						if (window._startInventoryRenderLoop) {
							window._startInventoryRenderLoop();
						}
					}
				};
				playerImage.src = 'media/player.png';
				
				// Rotation state (stored on canvas for persistence)
				// Use same system as player.js: angles and targetAngles with interpolation
				// player.js: angles[0] = pitch, angles[1] = yaw
				canvas._angles = [0, Math.PI]; // [pitch, yaw] - start facing forward (same as player.js default)
				canvas._targetYaw = Math.PI;
				canvas._targetPitch = 0;
				// Backwards compatibility
				canvas._modelYaw = Math.PI;
				canvas._modelPitch = 0;
				
				// Make canvas and context accessible globally
				window._inventoryPlayerCanvas = canvas;
				window._inventoryPlayerCtx = ctx;
				
				// Global function to update model rotation (accessible from document listener)
				// Model follows mouse anywhere on screen, like in vanilla Minecraft
				window.updateInventoryPlayerModelRotation = function(e) {
					// Check if inventory is open
					var inventory = document.getElementById('inventory');
					if (!inventory || inventory.style.display !== 'flex') {
						return;
					}
					
					var canvas = window._inventoryPlayerCanvas;
					if (!canvas || !canvas._playerTexture || !canvas._ctx) {
						return; // Canvas or texture not ready
					}
					
					var container = canvas.parentElement;
					if (!container) return;
					
					// Get container bounds (accounting for GUI scale)
					var rect = container.getBoundingClientRect();
					
					// Calculate mouse position relative to container center
					var centerX = rect.left + rect.width / 2;
					var centerY = rect.top + rect.height / 2;
					
					// Calculate distance from center (for rotation calculation)
					var deltaX = e.clientX - centerX;
					var deltaY = e.clientY - centerY;
					
					// In vanilla Minecraft, the model rotates directly based on mouse position
					// The rotation range is approximately 췀90 degrees (/2 radians)
					// Calculate rotation angles based on mouse position relative to center
					// Sensitivity: the model rotates ~ radians (180춿) when mouse is at edge of container
					var maxRotation = Math.PI / 2; // Max 90 degrees rotation
					var sensitivity = Math.max(rect.width, rect.height) / 2; // Use max dimension for consistent rotation
					
					// Calculate rotation angles (yaw and pitch)
					// Yaw: rotation around Y axis (horizontal) - based on mouse X position
					var normalizedX = Math.max(-1, Math.min(1, deltaX / sensitivity));
					// Pitch: rotation around X axis (vertical) - based on mouse Y position  
					var normalizedY = Math.max(-1, Math.min(1, deltaY / sensitivity));
					
					// Ensure target angles are initialized
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					
					// Update target angles
					// Base yaw is Math.PI (facing forward/away from camera in inventory)
					// Positive deltaX (mouse right) = rotate model right (increase yaw)
					canvas._targetYaw = Math.PI + (normalizedX * maxRotation);
					
					// Pitch: mouse down = model looks down (negative pitch)
					canvas._targetPitch = -(normalizedY * maxRotation);
					
					// Clamp target pitch to prevent extreme angles
					if (canvas._targetPitch < -Math.PI/2) canvas._targetPitch = -Math.PI/2;
					if (canvas._targetPitch > Math.PI/2) canvas._targetPitch = Math.PI/2;
					
					// Store last mouse event for continuous tracking
					canvas._lastMouseEvent = e;
				};
				
				// Track mouse position constantly - store last position to maintain rotation
				// Store on canvas so it persists across function scopes
				canvas._lastMouseEvent = null;
				
				// Track mouse movement globally (always track, not just when inventory is open)
				// This ensures mouse position is always available when inventory opens
				document.addEventListener('mousemove', function(e) {
					var canvas = window._inventoryPlayerCanvas;
					if (canvas) {
						// Always store mouse position for continuous tracking
						canvas._lastMouseX = e.clientX;
						canvas._lastMouseY = e.clientY;
						canvas._lastMouseEvent = e;
					}
					
					// Check if inventory is open for immediate update
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						// Also update immediately for instant response
						if (window.updateInventoryPlayerModelRotation) {
							window.updateInventoryPlayerModelRotation(e);
						}
					}
				});
				
				// Mouse position is now tracked continuously in mousemove listener above
				// The render loop will use the stored position to update rotation each frame
				
				// Render loop for continuous updates when inventory is open
				// Uses requestAnimationFrame for smooth, browser-synchronized rendering
				// Uses same interpolation system as player.js (line 864-865)
				var renderLoopAnimationFrame = null;
				var lastUpdateTime = Date.now();
				
				var renderFrame = function() {
					var inventory = document.getElementById('inventory');
					// Check if we should continue rendering
					if (inventory && inventory.style.display === 'flex' && canvas && canvas._ctx) {
						// If texture not loaded yet, skip rendering but continue loop
						if (!canvas._playerTexture) {
							renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
							return;
						}
						
						// Ensure angles are initialized
						if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
						if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
						if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
						if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
						
						// Update target angles based on current mouse position (replicating player.js rotation system)
						var container = canvas.parentElement;
						if (container) {
							var rect = container.getBoundingClientRect();
							var centerX = rect.left + rect.width / 2;
							var centerY = rect.top + rect.height / 2;
							
							// Always use stored last mouse position (updated by mousemove listener)
							// If not available yet, use center (default position)
							var mouseX = (canvas._lastMouseX !== undefined && canvas._lastMouseX !== null) ? canvas._lastMouseX : centerX;
							var mouseY = (canvas._lastMouseY !== undefined && canvas._lastMouseY !== null) ? canvas._lastMouseY : centerY;
							
							// Calculate delta from center (like movementX/Y in player.js)
							var deltaX = mouseX - centerX;
							var deltaY = mouseY - centerY;
							
							// Ensure angles are initialized (same as player.js: angles[0] = pitch, angles[1] = yaw)
							if (canvas._angles === undefined) {
								canvas._angles = [0, Math.PI]; // [pitch, yaw] - start facing forward
							}
							if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
							if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
							
							// Update target angles based on mouse position (replicating player.js onMouseMove)
							// player.js: this.targetPitch = this.angles[0] - deltaY / 200;
							//           this.targetYaw = this.angles[1] + deltaX / 200;
							// For inventory: use sensitivity based on container size (similar to /200 sensitivity)
							var sensitivity = 200; // Same sensitivity as player.js
							// Calculate sensitivity multiplier based on container size to match player.js behavior
							var sensitivityMultiplier = Math.max(rect.width, rect.height) / 100; // Adjust based on container size
							
							// Update target angles (replicating player.js onMouseMove logic)
							canvas._targetPitch = canvas._angles[0] - (deltaY / (sensitivity * sensitivityMultiplier));
							canvas._targetYaw = canvas._angles[1] + (deltaX / (sensitivity * sensitivityMultiplier));
							
							// Clamp target pitch (same as player.js)
							if (canvas._targetPitch < -Math.PI/2) canvas._targetPitch = -Math.PI/2;
							if (canvas._targetPitch > Math.PI/2) canvas._targetPitch = Math.PI/2;
						}
						
						// Interpolate angles towards target (same as player.js update() - line 3948-3949)
						// player.js: this.angles[0] += ( this.targetPitch - this.angles[0] ) * 30 * delta;
						//           this.angles[1] += ( this.targetYaw - this.angles[1] ) * 30 * delta;
						var now = Date.now();
						var delta = (now - lastUpdateTime) / 1000; // Convert to seconds
						lastUpdateTime = now;
						
						// Ensure angles array is initialized
						if (canvas._angles === undefined) {
							canvas._angles = [0, Math.PI]; // [pitch, yaw]
						}
						if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
						if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
						
						// Interpolate with same speed as player.js (30 * delta)
						var interpolationSpeed = 30; // Same as player.js
						canvas._angles[0] += (canvas._targetPitch - canvas._angles[0]) * interpolationSpeed * delta;
						canvas._angles[1] += (canvas._targetYaw - canvas._angles[1]) * interpolationSpeed * delta;
						
						// Clamp pitch (same as player.js line 3950-3951)
						if (canvas._angles[0] < -Math.PI/2) canvas._angles[0] = -Math.PI/2;
						if (canvas._angles[0] > Math.PI/2) canvas._angles[0] = Math.PI/2;
						
						// Use interpolated angles for rendering (same as render.js uses player.angles)
						// render.js: Math.PI - player.angles[1] for yaw, -pitch for pitch
						var renderYaw = canvas._angles[1]; // Will be converted to Math.PI - yaw in render function
						var renderPitch = canvas._angles[0]; // Will be converted to -pitch in render function
						
						// Also update model angles for backwards compatibility
						canvas._modelYaw = renderYaw;
						canvas._modelPitch = renderPitch;
						
						// Render with interpolated angles (same as render.js uses player.angles)
						// render.js: Math.PI - player.angles[1] for yaw, -pitch for pitch
						if (canvas._ctx && canvas._playerTexture) {
							// Pass angles as they are - render function will apply Math.PI - yaw and -pitch
							renderInventoryPlayerModel(canvas._ctx, canvas, renderYaw, renderPitch);
						}
						
						// Schedule next frame
						renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
					} else {
						// Stop loop if inventory closed
						if (renderLoopAnimationFrame) {
							cancelAnimationFrame(renderLoopAnimationFrame);
							renderLoopAnimationFrame = null;
							canvas._renderLoopActive = false;
						}
					}
				};
				
				var startRenderLoop = function() {
					// Check if loop already exists (stored on canvas)
					if (canvas._renderLoopActive || renderLoopAnimationFrame) {
						// Already running, just ensure it continues
						return;
					}
					
					// Ensure canvas and context are available
					if (!canvas || !canvas._ctx) {
						console.log('Canvas or context not ready for render loop');
						return;
					}
					
					lastUpdateTime = Date.now();
					canvas._renderLoopActive = true;
					
					// Initialize angles if not set (same as player.js)
					if (canvas._angles === undefined) {
						canvas._angles = [0, Math.PI]; // [pitch, yaw] - same as player.js default
					}
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					// Backwards compatibility
					if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
					if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
					
					// Force initial render if texture is loaded
					if (canvas._playerTexture && canvas._ctx) {
						renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
					}
					
					// Start the animation frame loop
					console.log('Starting inventory render loop');
					renderLoopAnimationFrame = requestAnimationFrame(renderFrame);
				};
				
				// Start render loop when inventory opens
				var inventory = document.getElementById('inventory');
				if (inventory) {
					var observer = new MutationObserver(function(mutations) {
						for (var i = 0; i < mutations.length; i++) {
							var mutation = mutations[i];
							if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
								var display = inventory.style.display;
								if (display === 'flex') {
									// Wait for texture to load if not ready
									if (!canvas._playerTexture) {
										console.log('Waiting for player texture to load...');
										// Texture will load and trigger render, but we should still start the loop
									}
									
									// Initialize mouse position if not set yet
									// Use center of container as default
									var container = canvas.parentElement;
									if (container && (canvas._lastMouseX === undefined || canvas._lastMouseX === null)) {
										var rect = container.getBoundingClientRect();
										canvas._lastMouseX = rect.left + rect.width / 2;
										canvas._lastMouseY = rect.top + rect.height / 2;
									}
									
									// Ensure rotation state is initialized (same as player.js)
									if (canvas._angles === undefined) {
										canvas._angles = [0, Math.PI]; // [pitch, yaw] - same as player.js default
									}
									if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
									if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
									// Backwards compatibility
									if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
									if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
									
									// Store startRenderLoop globally so it can be called when texture loads
									window._startInventoryRenderLoop = startRenderLoop;
									
									// Inventory opened, start render loop
									startRenderLoop();
									
									// Initial render if texture is ready
									setTimeout(function() {
										if (canvas && canvas._ctx && canvas._playerTexture) {
											renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
										}
									}, 10);
								} else if (display === 'none') {
									// Inventory closed, stop render loop and reset rotation
									if (renderLoopAnimationFrame) {
										cancelAnimationFrame(renderLoopAnimationFrame);
										renderLoopAnimationFrame = null;
										canvas._renderLoopActive = false;
									}
									// Reset to default angles (same as player.js: angles = [0, Math.PI, 0])
									canvas._modelYaw = Math.PI;
									canvas._modelPitch = 0;
									canvas._targetYaw = Math.PI;
									canvas._targetPitch = 0;
								}
							}
						}
					});
					observer.observe(inventory, { attributes: true, attributeFilter: ['style'] });
				}
			}
			
			// Global function to render inventory player model (accessible from anywhere)
			window.renderInventoryPlayerModel = function(yaw, pitch) {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) return;
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Use stored rotation if not provided
				if (yaw === undefined) yaw = canvas._modelYaw || 0;
				if (pitch === undefined) pitch = canvas._modelPitch || 0;
				
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			};
			
			// Render the 3D player model using Canvas 2D (same rotation logic as render.js)
			// Model is centered in the canvas and rotates like the player in-game
			function renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch) {
				if (!canvas._playerTexture) {
					console.log('No texture loaded yet');
					return;
				}
				
				// Clear canvas with transparent background
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.imageSmoothingEnabled = false; // Pixelated rendering
				
				var img = canvas._playerTexture;
				var centerX = canvas.width / 2;
				var centerY = canvas.height / 2;
				// Calculate scale to fit model in canvas (52x70px base size, before GUI scale)
				// Model dimensions at scale 1: head (8px) + body (12px) + legs (12px) = 32px height
				// Model width at scale 1: body (8px) + arms (4px each side) 곋 16px
				// In vanilla Minecraft, the inventory player model is slightly smaller to fit better
				// Adjust scale to match vanilla proportions - scale of 2.0 gives better visibility
				var scale = 2.0; // Increased scale for better visibility, like vanilla Minecraft
				
				var bodyW = 8 * scale;
				var bodyH = 12 * scale;
				var headSize = 8 * scale;
				var armW = 4 * scale;
				var armH = 12 * scale;
				var legW = 4 * scale;
				var legH = 12 * scale;
				
				// Total model height (head + body + legs)
				var totalHeight = headSize + bodyH + legH;
				// Total model width (body + arms on each side)
				var totalWidth = bodyW + armW * 2;
				
				// Clamp pitch like in render.js (line 296-297)
				var clampedPitch = pitch;
				if (clampedPitch < -0.32) clampedPitch = -0.32;
				if (clampedPitch > 0.32) clampedPitch = 0.32;
				
				// Center the model in the canvas (like vanilla Minecraft)
				// Body center Y position: start from top of legs, go up by legH + bodyH/2
				var bodyCenterY = legH + bodyH/2;
				// Head center Y position: above body
				var headCenterY = legH + bodyH + headSize/2;
				// Total model center (vertical center of entire model)
				var modelCenterY = (legH + bodyH + headSize) / 2;
				
				// Offset to center the model in canvas - adjust slightly upward for better positioning
				var verticalOffset = centerY - modelCenterY - (scale * 2); // Slight upward offset for better centering
				
				// Draw body first - rotates with yaw only (like render.js line 319-323)
				ctx.save();
				ctx.translate(centerX, verticalOffset + bodyCenterY);
				// Rotate body with yaw (same as render.js: Math.PI - player.angles[1])
				// Canvas rotates clockwise for positive values, so we need Math.PI - yaw
				ctx.rotate(Math.PI - yaw);
				
				// Draw body centered
				ctx.drawImage(img, 20, 20, 8, 12, -bodyW/2, -bodyH/2, bodyW, bodyH);
				
				// Draw arms attached to body
				ctx.drawImage(img, 44, 20, 4, 12, -bodyW/2 - armW + 2, -armH/2, armW, armH);
				ctx.drawImage(img, 44, 20, 4, 12, bodyW/2 - 2, -armH/2, armW, armH);
				
				// Draw legs (below body)
				ctx.drawImage(img, 4, 20, 4, 12, -bodyW/4 - legW/2, bodyH/2, legW, legH);
				ctx.drawImage(img, 4, 20, 4, 12, bodyW/4 - legW/2, bodyH/2, legW, legH);
				
				// Draw head with rotation (like render.js line 311-312)
				// Head rotates with both yaw and pitch
				// Head position: above body
				var headOffsetY = -bodyH/2 - headSize/2; // Offset from body center to head center
				
				ctx.save();
				// Move to head center position (above body)
				ctx.translate(0, headOffsetY);
				// Apply yaw rotation (same as body, but head can also pitch)
				// In render.js: Math.PI - player.angles[1]
				ctx.rotate(Math.PI - yaw);
				// Apply pitch rotation (like render.js: -pitch)
				// In canvas 2D, we simulate pitch by scaling vertically and adjusting position
				var pitchScale = Math.cos(-clampedPitch); // Scale down when looking up/down
				var pitchOffset = Math.sin(-clampedPitch) * headSize * 0.3; // Offset for perspective
				ctx.scale(1, pitchScale);
				ctx.translate(0, pitchOffset);
				
				// Draw head centered
				ctx.drawImage(img, 8, 8, 8, 8, -headSize/2, -headSize/2, headSize, headSize);
				ctx.restore();
				
				ctx.restore();
			}
			
			// Keep old function name for backward compatibility
			function renderInventoryPlayerModel(ctx, canvas, yaw, pitch) {
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			}

			// Function to start the render loop
			function startGameLoop() {
				// Initialize CSS 3D player model rotation tracking
				setupInventoryPlayerModelCSS3D();
				
				// Use requestAnimationFrame for better performance and synchronization
				lastFrameTime = performance.now(); // Use global variable
				var frameId = null;
				
				function gameLoop(currentTime) {
					if (!paused) {
						var frameStart = performance.now();
						
						// If lastFrameTime is null or very old, reset it to prevent huge delta
						if (lastFrameTime === null || (currentTime - lastFrameTime) > 1000) {
							lastFrameTime = currentTime;
						}
						
						var deltaTime = (currentTime - lastFrameTime) / 1000.0; // Delta in seconds
						lastFrameTime = currentTime;
						
						// Limit delta to prevent large jumps
						if (deltaTime > 0.1) deltaTime = 0.1; // Max 100ms delta

						// Simulate physics
						measureTime('physics', function() {
							physics.simulate();
						});

						// Update animations (debe llamarse cada frame para animaciones suaves)
						if ( physics.updateAnimations ) {
							physics.updateAnimations();
							// Marcar chunks como dirty solo si contienen bloques animados
							if ( Object.keys( physics.fallingBlocks ).length > 0 ) {
								// Marcar solo los chunks que contienen bloques animados
								for ( var key in physics.fallingBlocks ) {
									var anim = physics.fallingBlocks[key];
									// Marcar el chunk que contiene este bloque animado
									render.onBlockChanged( anim.x, anim.startY, anim.z );
									// Tambi칠n marcar el chunk de destino si es diferente
									if ( anim.targetY != anim.startY ) {
										render.onBlockChanged( anim.x, anim.targetY, anim.z );
									}
								}
							}
						}

						// Update local player
						measureTime('playerUpdate', function() {
							player.update();
						});

						// Build chunks only if there are dirty chunks (optimization)
						measureTime('buildChunks', function() {
							if (render.dirtyChunks && render.dirtyChunks.length > 0) {
								// Build fewer chunks per frame to spread load
								render.buildChunks( 2 ); // Reduced from 8 to 2
							}
						});

						// Draw world
						measureTime('setCamera', function() {
							var eyePos = player.getEyePos();
							var cameraAngles = player.angles.slice(); // Copiar 치ngulos
							
							// Ajustar 치ngulos de la c치mara seg칰n el modo de perspectiva
							// En modo espectador, solo usar primera persona (no ajustar 치ngulos)
							if ( !player.spectatorMode && player.cameraMode === 2 ) {
								// Segunda persona: c치mara detr치s del jugador, mirando hacia donde mira el jugador
								cameraAngles[0] = player.angles[0];
								cameraAngles[1] = player.angles[1];
							} else if ( !player.spectatorMode && player.cameraMode === 3 ) {
								// Tercera persona: c치mara delante del jugador, conectada r칤gidamente a la cabeza
								// Si Steve baja la cabeza, la c치mara tambi칠n baja, pero la c치mara mira hacia arriba
								// Calcular direcci칩n desde la c치mara hacia el jugador
								var playerEyePos = player.pos.add( new Vector( 0.0, 1.7, 0.0 ) );
								var dx = playerEyePos.x - eyePos.x;
								var dy = playerEyePos.y - eyePos.y;
								var dz = playerEyePos.z - eyePos.z;
								
								// Calcular pitch (치ngulo vertical) hacia el jugador
								// Cuando el jugador mira hacia abajo (pitch negativo), la c치mara debe mirar hacia arriba (pitch positivo)
								// Por lo tanto, invertimos el pitch calculado
								var horizontalDist = Math.sqrt(dx * dx + dz * dz);
								if (horizontalDist > 0.001) {
									cameraAngles[0] = Math.atan2(dy, horizontalDist); // Invertido: sin el negativo
								} else {
									cameraAngles[0] = 0; // Si est치 directamente arriba/abajo, no inclinar
								}
								
								// Calcular yaw (치ngulo horizontal) hacia el jugador
								// En el sistema del juego, el movimiento usa: Math.cos(Math.PI/2 - yaw) para X y Math.sin(Math.PI/2 - yaw) para Z
								// Esto significa que yaw = 0 apunta hacia el norte (direcci칩n positiva de Z)
								// Para calcular el yaw desde la c치mara hacia el jugador:
								// - Necesitamos el 치ngulo que hace el vector (dx, dz) con el eje Z positivo
								// - Math.atan2(dx, dz) da el 치ngulo desde el eje Z hacia X
								// - Si dx=0 y dz>0 (norte), Math.atan2(0, 1) = 0, y queremos yaw = 0 九
								// - Si dx>0 y dz=0 (este), Math.atan2(1, 0) = PI/2, y queremos yaw = PI/2 九
								// - Por lo tanto, yaw = Math.atan2(dx, dz) es correcto
								if (horizontalDist > 0.001) {
									cameraAngles[1] = Math.atan2(dx, dz);
								} else {
									cameraAngles[1] = player.angles[1]; // Mantener el yaw del jugador si est치 directamente arriba/abajo
								}
							}
							
							render.setCamera( eyePos.toArray(), cameraAngles );
						});

						measureTime('draw', function() {
							render.draw();
							// Also capture updateChunks time if available
							if (render._updateChunksStats && render._updateChunksStats.count > 0) {
								var stat = render._updateChunksStats;
								var avg = stat.total / stat.count;
								if (!performanceStats.updateChunks) {
									performanceStats.updateChunks = { total: 0, count: 0, max: 0 };
								}
								performanceStats.updateChunks.total += avg * stat.count;
								performanceStats.updateChunks.count += stat.count;
								if (stat.max > performanceStats.updateChunks.max) {
									performanceStats.updateChunks.max = stat.max;
								}
								// Reset renderer stats
								render._updateChunksStats = { total: 0, count: 0, max: 0 };
							}
						});
						
						// Update debug overlay (only if enabled)
						if (debugEnabled) {
							updateDebugOverlay();
						}

						var frameTime = performance.now() - frameStart;
						measureTime('total', function() { return frameTime; });

						// Calculate FPS
						var currentTime = performance.now();
						frameCount++;
						if (currentTime - lastTime >= 1000) {
							fps = frameCount;
							frameCount = 0;
							lastTime = currentTime;
							if (document.getElementById('fpsDisplay').style.display !== 'none') {
								document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
							}
							// Log performance stats every second
							logPerformanceStats();
						}
					} else {
						// Game is paused - reset lastFrameTime so we don't accumulate a huge delta
						// This prevents massive catch-up when resuming
						lastFrameTime = performance.now();
					}
					
					// Always schedule next frame, but only process game logic if not paused
					frameId = requestAnimationFrame(gameLoop);
				}
				
				// Start the loop
				frameId = requestAnimationFrame(gameLoop);
				gameLoopInterval = { frameId: frameId, cancel: function() { if (this.frameId) cancelAnimationFrame(this.frameId); } }; // Store for cleanup
			}

			// Update debug overlay with player information
			function updateDebugOverlay() {
				if (!player || !world) return;
				
				var pos = player.pos;
				var eyePos = player.getEyePos();
				var angles = player.angles;
				
				// Calcular bloque actual (donde est치 el jugador)
				// Ejes: X y Z = horizontal, Y = vertical (altura)
				var blockX = Math.floor(pos.x);
				var blockY = Math.floor(pos.y);
				var blockZ = Math.floor(pos.z);
				var block = world.getBlock(blockX, blockY, blockZ);
				
				// Intentar obtener el bloque que el jugador est치 mirando (usando pickAt)
				var lookedBlock = null;
				var lookedBlockX = blockX;
				var lookedBlockY = blockY;
				var lookedBlockZ = blockZ;
				if (render && render.pickAt) {
					var bPos = new Vector(blockX, blockY, blockZ);
					var centerX = render.canvas ? render.canvas.width / 2 : 0;
					var centerY = render.canvas ? render.canvas.height / 2 : 0;
					var pickedBlock = render.pickAt(
						new Vector(blockX - 4, Math.max(0, blockY - 2), blockZ - 4),
						new Vector(blockX + 4, Math.min(world.sy - 1, blockY + 2), blockZ + 4),
						centerX, centerY
					);
					if (pickedBlock && pickedBlock != false) {
						lookedBlock = world.getBlock(pickedBlock.x, pickedBlock.y, pickedBlock.z);
						lookedBlockX = pickedBlock.x;
						lookedBlockY = pickedBlock.y;
						lookedBlockZ = pickedBlock.z;
					}
				}
				
				// Usar el bloque que el jugador est치 mirando si est치 disponible, sino el bloque donde est치 parado
				var displayBlock = lookedBlock || block;
				var displayBlockX = lookedBlock ? lookedBlockX : blockX;
				var displayBlockY = lookedBlock ? lookedBlockY : blockY;
				var displayBlockZ = lookedBlock ? lookedBlockZ : blockZ;
				
				// Obtener nombre del bloque
				var blockName = 'AIR';
				if (displayBlock && displayBlock != BLOCK.AIR) {
					// Buscar el nombre del bloque comparando con los objetos BLOCK
					for (var key in BLOCK) {
						if (BLOCK[key] === displayBlock && typeof BLOCK[key] === 'object' && BLOCK[key].id !== undefined) {
							blockName = key;
							break;
						}
					}
					if (blockName === 'AIR') {
						blockName = 'UNKNOWN';
					}
				}
				
				// Calcular direcci칩n (yaw en radianes, 0 = Norte, PI/2 = Este, PI = Sur, 3*PI/2 = Oeste)
				var yaw = angles[1];
				// Normalizar yaw a 0-2*PI
				while (yaw < 0) yaw += 2 * Math.PI;
				while (yaw >= 2 * Math.PI) yaw -= 2 * Math.PI;
				
				var direction = '';
				var yawDegrees = (yaw * 180 / Math.PI) % 360;
				if (yawDegrees < 0) yawDegrees += 360;
				
				// Determinar direcci칩n cardinal
				if (yawDegrees >= 337.5 || yawDegrees < 22.5) direction = 'Norte';
				else if (yawDegrees >= 22.5 && yawDegrees < 67.5) direction = 'Noreste';
				else if (yawDegrees >= 67.5 && yawDegrees < 112.5) direction = 'Este';
				else if (yawDegrees >= 112.5 && yawDegrees < 157.5) direction = 'Sureste';
				else if (yawDegrees >= 157.5 && yawDegrees < 202.5) direction = 'Sur';
				else if (yawDegrees >= 202.5 && yawDegrees < 247.5) direction = 'Suroeste';
				else if (yawDegrees >= 247.5 && yawDegrees < 292.5) direction = 'Oeste';
				else if (yawDegrees >= 292.5 && yawDegrees < 337.5) direction = 'Noroeste';
				
				var debugHTML = '<div style="background: rgba(0,0,0,0.5); padding: 8px; border: 1px solid #00ff00;">';
				debugHTML += '<div><strong>Minecraft Web Edition - Debug (F3)</strong></div>';
				if (player.spectatorMode) {
					debugHTML += '<div style="color: #ffaa00; font-weight: bold; margin-top: 4px;">丘 MODO ESPECTADOR (F4 para desactivar)</div>';
				}
				debugHTML += '<div style="margin-top: 8px;">';
				debugHTML += '<div>Posici칩n: X: ' + pos.x.toFixed(2) + ' Y: ' + pos.y.toFixed(2) + ' Z: ' + pos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Ojos: X: ' + eyePos.x.toFixed(2) + ' Y: ' + eyePos.y.toFixed(2) + ' Z: ' + eyePos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Bloque: X: ' + displayBlockX + ' Y: ' + displayBlockY + ' Z: ' + displayBlockZ + ' (' + blockName + ')</div>';
				debugHTML += '<div>Direcci칩n: ' + direction + ' (' + yawDegrees.toFixed(1) + '춿)</div>';
				debugHTML += '<div>Pitch: ' + (angles[0] * 180 / Math.PI).toFixed(1) + '춿</div>';
				
				// Informaci칩n de chunks si C+F3 est치 activo
				if (debugChunksEnabled) {
					// Ejes: X y Z = horizontal, Y = vertical (altura)
					var chunkX = Math.floor(pos.x / render.chunkSize);
					var chunkZ = Math.floor(pos.z / render.chunkSize); // Z es horizontal
					var chunkY = 0; // Siempre 0 porque solo hay un chunk vertical (cubre toda la altura Y)
					
					debugHTML += '<div style="margin-top: 8px; border-top: 1px solid #00ff00; padding-top: 8px;">';
					debugHTML += '<div><strong>Chunk Info (C+F3)</strong></div>';
					debugHTML += '<div>Chunk actual: [' + chunkX + ', ' + chunkY + ', ' + chunkZ + ']</div>';
					debugHTML += '<div>Tama침o chunk: ' + render.chunkSize + 'x' + render.chunkSize + 'x' + render.chunkSizeY + ' (X, Z, Y)</div>';
					
					// Chunks alrededor
					debugHTML += '<div style="margin-top: 4px;">Chunks cargados: ';
					if (render.loadedChunks) {
						debugHTML += render.loadedChunks.size || 0;
					} else {
						debugHTML += '0';
					}
					debugHTML += '</div>';
					
					// Chunks cercanos
					debugHTML += '<div style="margin-top: 4px;">Chunks cercanos:</div>';
					var nearbyChunks = [];
					for (var dx = -1; dx <= 1; dx++) {
						for (var dy = -1; dy <= 1; dy++) {
							var cx = chunkX + dx;
							var cy = chunkY + dy;
							var cz = 0;
							var key = render.getChunkKey ? render.getChunkKey(cx, cy, cz) : (cx + '|' + cy + '|' + cz);
							var chunk = render.chunkLookup && render.chunkLookup[key];
							var loaded = chunk && chunk.loaded;
							nearbyChunks.push('[' + cx + ',' + cy + ',' + cz + ']' + (loaded ? '九' : '九'));
						}
					}
					debugHTML += '<div style="font-size: 10px;">' + nearbyChunks.join(' ') + '</div>';
					debugHTML += '</div>';
				}
				
				debugHTML += '</div>';
				debugHTML += '</div>';
				
				document.getElementById('debugInfo').innerHTML = debugHTML;
			}
			
			// Function to pause the game
			function pauseGame() {
				paused = true;
				document.getElementById('pauseOverlay').style.display = 'block';
				document.getElementById('pauseMenu').style.display = 'flex';
				document.getElementById('crosshair').style.display = 'none';
				document.getElementById('cursor').style.display = 'block';
				if ( player ) {
					player.pointerLocked = false;
					player.dragging = false;
					// Reset lastUpdate when pausing to prevent large delta on resume
					player.lastUpdate = new Date().getTime();
				}
				// Mostrar bot칩n VR en el men칰 de pausa
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			}

			// Function to resume the game
			function resumeGame() {
				paused = false;
				document.getElementById('pauseOverlay').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				// Ocultar bot칩n VR al reanudar el juego
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'none';
				}
				
				// Reset lastFrameTime BEFORE requesting pointer lock to prevent huge delta
				// This prevents the game from trying to catch up with all the paused time
				lastFrameTime = performance.now();
				
				// Reset FPS tracking when resuming
				lastTime = performance.now();
				frameCount = 0;
				
				// Reset player's lastUpdate to prevent large delta when resuming
				// This prevents the player from falling through the world
				if ( player && player.lastUpdate ) {
					player.lastUpdate = new Date().getTime();
				}
				
				// Reset renderer's updateChunks state to prevent immediate massive update
				if ( render ) {
					render._updateChunksState = null;
					render._loadIndex = 0;
					render._unloadIndex = 0;
					// Delay first updateChunks call by setting frame count high
					// This gives the game a few frames to stabilize before chunk updates
					render._updateChunksFrameCount = 10; // Wait 10 frames before first update
				}
				
				// Request pointer lock after a small delay to ensure state is reset
				if ( player && player.canvas ) {
					setTimeout(function() {
						if (player && player.canvas && !paused) {
							player.canvas.requestPointerLock();
						}
					}, 50); // Small delay to let state settle
				}
			}

			function playClickSound() { // detects when the player touches a button in the gui
                clickSound.currentTime = 0;
                clickSound.play().catch(function(e) { console.log('Audio play failed:', e); });
            }

			// Pause menu event handlers
			document.getElementById('resumeButton').onclick = function() {
				resumeGame();
			};

			document.getElementById('pauseSettingsButton').onclick = function() {
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'flex';
				// Mantener bot칩n VR visible en el men칰 de ajustes
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			};

			document.getElementById('exitButton').onclick = async function() {
				console.log("Saving game data before exit...");
				
				// Guardar todos los chunks modificados (esperar a que termine)
				if ( world && world.saveAllLoadedChunks ) {
					try {
						var savedChunks = await world.saveAllLoadedChunks();
						console.log("Saved", savedChunks, "modified chunks");
					} catch (e) {
						console.warn("Error saving chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Player data saved successfully");
					} catch (e) {
						console.warn("Could not save player data:", e);
					}
				}
				
				// Redirigir inmediatamente (los datos ya est치n guardados)
				window.location.href = 'index.html';
			};

			// Pause settings menu event handlers
			document.getElementById('pauseSettingsBackButton').onclick = function() {
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'flex';
				// Mantener bot칩n VR visible al volver al men칰 de pausa
				var vrButton = document.getElementById('vr-button');
				if (vrButton) {
					vrButton.style.display = 'block';
				}
			};

			pauseRenderDistanceSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseRenderDistanceValue.textContent = value;
				localStorage.setItem('renderDistance', value);
				if ( render ) render.setRenderDistance(value);
			};

			pauseGuiScaleSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseGuiScaleValue.textContent = value;
				setGuiScale(value);
			};

			pauseFpsToggle.onchange = function() {
				localStorage.setItem('showFPS', pauseFpsToggle.checked);
				if (pauseFpsToggle.checked) {
					document.getElementById('fpsDisplay').style.display = 'block';
				} else {
					document.getElementById('fpsDisplay').style.display = 'none';
				}
			};
			
			// Funci칩n para guardar todos los datos (chunks y jugador)
			async function saveAllGameData() {
				// Guardar chunks modificados
				if ( world && world.saveAllLoadedChunks ) {
					try {
						await world.saveAllLoadedChunks();
						console.log("Auto-saved chunks");
					} catch (e) {
						console.warn("Could not auto-save chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Auto-saved player data");
					} catch (e) {
						console.warn("Could not auto-save player data:", e);
					}
				}
			}
			
			// Auto-guardar datos del jugador cada 60 segundos (solo posici칩n/inventario, NO chunks)
			// Los chunks se mantienen en RAM y solo se guardan al salir del mundo
			var autoSaveInterval = setInterval(function() {
				if ( !paused && world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
					} catch (e) {
						console.warn("Auto-save player data failed:", e);
					}
				}
			}, 60000);
			
			// Guardar chunks cuando se cierra la pesta침a o el navegador
			window.addEventListener('beforeunload', function() {
				// Usar localStorage como backup r치pido para datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Could not backup player data:", e);
					}
				}
				
				// Intentar guardar chunks (puede no completarse si se cierra muy r치pido)
				if ( world && world.saveAllLoadedChunks ) {
					world.saveAllLoadedChunks();
				}
			});
			
			// Guardar cuando la pesta침a se oculta (칰til para m칩viles)
			document.addEventListener('visibilitychange', function() {
				if ( document.hidden && world && world.worldId && player ) {
					// Solo guardar datos del jugador (r치pido)
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Visibility save failed:", e);
					}
				}
			});
		</script>
	</body>
</html lang="es">
