<!DOCTYPE HTML>
<html lang="es">
	<head>
		<title>minecraft web edition 0.0.0</title>
		
		<!-- Character encoding -->
		<meta http-equiv="content-type" content="text/html" charset="UTF-8">
		
		<!-- Stylesheet -->
		<link href="style/main.css" rel="stylesheet" type="text/css">
		
		<!-- Modules -->
		<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
		<script src="js/blocks.js" type="text/javascript"></script>
		<script src="js/helpers.js" type="text/javascript"></script>
		<script src="js/world.js" type="text/javascript"></script>
		<script src="js/render.js" type="text/javascript"></script>
		<script src="js/physics.js" type="text/javascript"></script>
		<script src="js/player.js" type="text/javascript"></script>
	</head>
	
	<body oncontextmenu="return false">
		<!-- Loads the gui audio for buttons -->
		<audio id="clickSound" src="sounds/gui/Click_stereo.ogg.mp3" preload="auto"></audio>
		<!-- Render surface -->
		<canvas id="renderSurface"></canvas>

		<img id="cursor" class="cursor" src="media/gui/cursor.png" />
		<img id="crosshair" class="crosshair" src="media/gui/cursor.png" />

		<!-- FPS Display -->
		<div id="fpsDisplay" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Minecraftia; display: none;"></div>

		<!-- Material selection -->
		<table id="materialSelector">
			<tr></tr>
		</table>

		<!-- Pause overlay -->
		<div id="pauseOverlay" class="gui-overlay" style="display: none;"></div>

		<!-- Pause menu -->
		<div id="pauseMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button id="resumeButton" class="button">Volver al juego</button>
				<button id="pauseSettingsButton" class="button">Ajustes</button>
				<button id="exitButton" class="button">Salir al menu principal</button>
			</div>
		</div>

		<!-- Pause settings menu -->
		<div id="pauseSettingsMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button class="button" id="pauseSettingsBackButton">Volver</button>
				<div style="margin: 20px 0;">
					<label for="pauseRenderDistanceSlider" style="color: white; font-family: Minecraftia;">Render Distance: <span id="pauseRenderDistanceValue">8</span> chunks</label><br>
					<input type="range" id="pauseRenderDistanceSlider" min="4" max="16" value="8" step="1" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label style="color: white; font-family: Minecraftia;">
						<input type="checkbox" id="pauseFpsToggle" style="margin-right: 10px;">Mostrar FPS
					</label>
				</div>
			</div>
		</div>
		
		<!-- Initialisation code -->
		<script type="text/javascript">
			
			const DEFAULT_SEED_NAME = "flat_default_seed";
			const SEED_API_ENDPOINT = "api/seeds.php";
			const ACTIVE_SEED_KEY = "activeSeedName";
			const SEED_SELECTION_KEY = "selectedSeed";

			var world;
			var render;
			var physics;
			var player;

			// Game state
			var paused = false;
			var gameLoopInterval;

			// FPS tracking
			var fps = 0;
			var lastTime = performance.now();
			var frameCount = 0;

			// Performance profiling
			var performanceStats = {
				physics: { total: 0, count: 0, max: 0 },
				playerUpdate: { total: 0, count: 0, max: 0 },
				buildChunks: { total: 0, count: 0, max: 0 },
				updateChunks: { total: 0, count: 0, max: 0 },
				setCamera: { total: 0, count: 0, max: 0 },
				draw: { total: 0, count: 0, max: 0 },
				total: { total: 0, count: 0, max: 0 }
			};

			function measureTime(statName, fn) {
				var start = performance.now();
				var result = fn();
				var elapsed = performance.now() - start;
				var stat = performanceStats[statName];
				if (stat) {
					stat.total += elapsed;
					stat.count++;
					if (elapsed > stat.max) stat.max = elapsed;
				}
				return result;
			}

			// Make performance stats available globally for debugging
			window.performanceStats = performanceStats;

			function logPerformanceStats() {
				if (performanceStats.total.count === 0) return;
				console.log("=== Performance Stats (last second) ===");
				for (var key in performanceStats) {
					var stat = performanceStats[key];
					if (stat.count > 0) {
						var avg = stat.total / stat.count;
						console.log(key + ": avg=" + avg.toFixed(2) + "ms, max=" + stat.max.toFixed(2) + "ms, calls=" + stat.count);
					}
				}
				// Reset stats
				for (var key in performanceStats) {
					performanceStats[key] = { total: 0, count: 0, max: 0 };
				}
			}

			var pauseRenderDistanceSlider = document.getElementById('pauseRenderDistanceSlider');
			var pauseRenderDistanceValue = document.getElementById('pauseRenderDistanceValue');
			var pauseFpsToggle = document.getElementById('pauseFpsToggle');

			initGame();

			async function initGame() {
				try {
					var seedName = localStorage.getItem( SEED_SELECTION_KEY ) || DEFAULT_SEED_NAME;
					var seedDefinition = await fetchSeedDefinition( seedName );
					world = buildWorldFromSeed( seedDefinition, seedName );
					localStorage.setItem( SEED_SELECTION_KEY, seedName );
				} catch ( error ) {
					console.warn( "Fallo la carga de la seed remota, se usará un mundo plano local.", error );
					world = buildFallbackWorld();
				}

				setupGameSystems();
				initialisePauseSettings();
				startGameLoop();
			}

			function fetchSeedDefinition( seedName ) {
				return fetch( SEED_API_ENDPOINT + "?name=" + encodeURIComponent( seedName ), { cache: "no-store" } )
					.then( function( response ) {
						if ( !response.ok ) {
							throw new Error( "Seed API devolvió " + response.status );
						}
						return response.json();
					} );
			}

			function buildWorldFromSeed( seedDefinition, seedName ) {
				var sx = seedDefinition.sx || 255;
				var sy = seedDefinition.sy || 255;
				var sz = seedDefinition.sz || 255;
				var chunkSize = seedDefinition.chunkSize || 16;
				var w = new World( sx, sy, sz );
				if ( w.setChunking ) w.setChunking( chunkSize );

				if ( Array.isArray( seedDefinition.chunks ) && seedDefinition.chunks.length ) {
					preloadSeedChunks( w, seedDefinition.chunks, seedName );
				} else if ( typeof seedDefinition.blocks === "string" && seedDefinition.blocks.length ) {
					w.createFromString( seedDefinition.blocks );
				} else if ( typeof seedDefinition.height === "number" ) {
					w.createFlatWorld( seedDefinition.height );
				} else {
					w.createFlatWorld( 256 );
				}

				var spawn = seedDefinition.spawn || [ sx / 2 + 0.5, sy / 2 + 0.5, 64 ];
				w.spawn = new Vector( spawn[0], spawn[1], spawn[2] );
				return w;
			}

			function preloadSeedChunks( worldInstance, chunks, seedName ) {
				if ( typeof localStorage === "undefined" ) return;

				var previousSeed = localStorage.getItem( ACTIVE_SEED_KEY );
				if ( previousSeed !== seedName ) {
					clearStoredChunkCache( worldInstance.chunkStoragePrefix );
				}

				for ( var i = 0; i < chunks.length; i++ ) {
					var chunkDef = chunks[i];
					if ( typeof chunkDef.data !== "string" ) continue;
					var key = chunkDef.cx + "|" + chunkDef.cy + "|" + chunkDef.cz;
					try {
						localStorage.setItem( worldInstance.chunkStoragePrefix + key, chunkDef.data );
						if ( worldInstance.chunkStates ) worldInstance.chunkStates[key] = "stored";
					} catch ( e ) {
						console.warn( "No se pudo guardar el chunk " + key + " en localStorage.", e );
						break;
					}
				}

				localStorage.setItem( ACTIVE_SEED_KEY, seedName );
			}

			function clearStoredChunkCache( prefix ) {
				if ( typeof localStorage === "undefined" ) return;
				var keysToDelete = [];
				for ( var i = 0; i < localStorage.length; i++ ) {
					var key = localStorage.key( i );
					if ( key && key.indexOf( prefix ) === 0 ) keysToDelete.push( key );
				}
				for ( var k = 0; k < keysToDelete.length; k++ ) {
					localStorage.removeItem( keysToDelete[k] );
				}
			}

			function buildFallbackWorld() {
				var fallbackWorld = new World( 128, 128, 128 );
				fallbackWorld.createFlatWorld( 4 );
				return fallbackWorld;
			}

			function setupGameSystems() {
				render = new Renderer( "renderSurface" );
				render.setWorld( world, 8 );
				render.setPerspective( 60, 0.01, 200 );

				physics = new Physics();
				physics.setWorld( world );

				player = new Player();
				player.setWorld( world );
				player.setPhysics( physics );
				player.setInputCanvas( "renderSurface" );
				player.setMaterialSelector( "materialSelector" );
			}

			function initialisePauseSettings() {
				var savedRenderDistance = localStorage.getItem('renderDistance') || '8';
				pauseRenderDistanceSlider.value = savedRenderDistance;
				pauseRenderDistanceValue.textContent = savedRenderDistance;
				render.setRenderDistance(parseInt(savedRenderDistance));

				var savedShowFPS = localStorage.getItem('showFPS') || 'false';
				pauseFpsToggle.checked = savedShowFPS === 'true';
				if (savedShowFPS === 'true') {
					document.getElementById('fpsDisplay').style.display = 'block';
				}
			}

			// Function to start the render loop
			function startGameLoop() {
				gameLoopInterval = setInterval( function()
				{
					if (!paused) {
						var frameStart = performance.now();
						var time = new Date().getTime() / 1000.0;

						// Simulate physics
						measureTime('physics', function() {
							physics.simulate();
						});

						// Update local player
						measureTime('playerUpdate', function() {
							player.update();
						});

						// Build a chunk
						measureTime('buildChunks', function() {
							render.buildChunks( 32 );
						});

						// Draw world
						measureTime('setCamera', function() {
							render.setCamera( player.getEyePos().toArray(), player.angles );
						});

						measureTime('draw', function() {
							render.draw();
							// Also capture updateChunks time if available
							if (render._updateChunksStats && render._updateChunksStats.count > 0) {
								var stat = render._updateChunksStats;
								var avg = stat.total / stat.count;
								if (!performanceStats.updateChunks) {
									performanceStats.updateChunks = { total: 0, count: 0, max: 0 };
								}
								performanceStats.updateChunks.total += avg * stat.count;
								performanceStats.updateChunks.count += stat.count;
								if (stat.max > performanceStats.updateChunks.max) {
									performanceStats.updateChunks.max = stat.max;
								}
								// Reset renderer stats
								render._updateChunksStats = { total: 0, count: 0, max: 0 };
							}
						});

						var frameTime = performance.now() - frameStart;
						measureTime('total', function() { return frameTime; });

						// Calculate FPS
						var currentTime = performance.now();
						frameCount++;
						if (currentTime - lastTime >= 1000) {
							fps = frameCount;
							frameCount = 0;
							lastTime = currentTime;
							if (document.getElementById('fpsDisplay').style.display !== 'none') {
								document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
							}
							// Log performance stats every second
							logPerformanceStats();
						}

						while ( new Date().getTime() / 1000 - time < 0.016 );
					}
				}, 1 );
			}

			// Function to pause the game
			function pauseGame() {
				paused = true;
				document.getElementById('pauseOverlay').style.display = 'block';
				document.getElementById('pauseMenu').style.display = 'flex';
				document.getElementById('crosshair').style.display = 'none';
				document.getElementById('cursor').style.display = 'block';
				if ( player ) {
					player.pointerLocked = false;
					player.dragging = false;
					// Reset lastUpdate when pausing to prevent large delta on resume
					player.lastUpdate = new Date().getTime();
				}
			}

			// Function to resume the game
			function resumeGame() {
				paused = false;
				document.getElementById('pauseOverlay').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				if ( player && player.canvas ) {
					player.canvas.requestPointerLock();
				}
				// Reset FPS tracking when resuming
				lastTime = performance.now();
				frameCount = 0;
				
				// Reset player's lastUpdate to prevent large delta when resuming
				// This prevents the player from falling through the world
				if ( player && player.lastUpdate ) {
					player.lastUpdate = new Date().getTime();
				}
			}

			function playClickSound() { // detects when the player touches a button in the gui
                clickSound.currentTime = 0;
                clickSound.play().catch(function(e) { console.log('Audio play failed:', e); });
            }

			// Pause menu event handlers
			document.getElementById('resumeButton').onclick = function() {
				resumeGame();
			};

			document.getElementById('pauseSettingsButton').onclick = function() {
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'flex';
			};

			document.getElementById('exitButton').onclick = function() {
				window.location.href = 'index.html';
			};

			// Pause settings menu event handlers
			document.getElementById('pauseSettingsBackButton').onclick = function() {
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'flex';
			};

			pauseRenderDistanceSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseRenderDistanceValue.textContent = value;
				localStorage.setItem('renderDistance', value);
				if ( render ) render.setRenderDistance(value);
			};

			pauseFpsToggle.onchange = function() {
				localStorage.setItem('showFPS', pauseFpsToggle.checked);
				if (pauseFpsToggle.checked) {
					document.getElementById('fpsDisplay').style.display = 'block';
				} else {
					document.getElementById('fpsDisplay').style.display = 'none';
				}
			};
		</script>
	</body>
</html lang="es">
