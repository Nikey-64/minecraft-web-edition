<!DOCTYPE HTML>
<html lang="es">
	<head>
		<title>minecraft web edition 0.0.0-B</title>
		
		<!-- Character encoding -->
		<meta http-equiv="content-type" content="text/html" charset="UTF-8">
		
		<!-- Stylesheet -->
		<link href="style/main.css" rel="stylesheet" type="text/css">
		
		<!-- Modules -->
		<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
		<script src="js/blocks.js" type="text/javascript"></script>
		<script src="js/helpers.js" type="text/javascript"></script>
		<script src="js/world.js" type="text/javascript"></script>
		<script src="js/render.js" type="text/javascript"></script>
		<script src="js/physics.js" type="text/javascript"></script>
		<script src="js/player.js" type="text/javascript"></script>
	</head>
	
	<body oncontextmenu="return false">
		<!-- Loads the gui audio for buttons -->
		<audio id="clickSound" src="sounds/gui/Click_stereo.ogg.mp3" preload="auto"></audio>
		<!-- Render surface -->
		<canvas id="renderSurface"></canvas>

		<img id="cursor" class="cursor" src="media/gui/cursor.png" />
		<img id="crosshair" class="crosshair" src="media/gui/cursor.png" />

		<!-- FPS Display -->
		<div id="fpsDisplay" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Minecraftia; display: none;"></div>

		<!-- Debug Overlay (F3) -->
		<div id="debugOverlay" style="position: absolute; top: 10px; left: 10px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 1000;">
			<div id="debugInfo"></div>
		</div>

		<!-- Material selection -->
		<table id="materialSelector">
			<tr></tr>
		</table>

		<!-- Pause overlay -->
		<div id="pauseOverlay" class="gui-overlay" style="display: none;"></div>

		<!-- Pause menu -->
		<div id="pauseMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button id="resumeButton" class="button">Volver al juego</button>
				<button id="pauseSettingsButton" class="button">Ajustes</button>
				<button id="exitButton" class="button">Salir al menu principal</button>
			</div>
		</div>

		<!-- Pause settings menu -->
		<div id="pauseSettingsMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button class="button" id="pauseSettingsBackButton">Volver</button>
				<div style="margin: 20px 0;">
					<label for="pauseRenderDistanceSlider" style="color: white; font-family: Minecraftia;">Render Distance: <span id="pauseRenderDistanceValue">8</span> chunks</label><br>
					<input type="range" id="pauseRenderDistanceSlider" min="4" max="16" value="8" step="1" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label style="color: white; font-family: Minecraftia;">
						<input type="checkbox" id="pauseFpsToggle" style="margin-right: 10px;">Mostrar FPS
					</label>
				</div>
			</div>
		</div>
		
		<!-- Initialisation code -->
		<script type="text/javascript">
			
			const DEFAULT_SEED_NAME = "flat_default_seed";
			const SEED_API_ENDPOINT = "api/seeds.php";
			const ACTIVE_SEED_KEY = "activeSeedName";
			const SEED_SELECTION_KEY = "selectedSeed";

			var world;
			var render;
			var physics;
			var player;

			// Game state
			var paused = false;
			var gameLoopInterval;
			
			// Debug state
			var debugEnabled = false;
			var debugChunksEnabled = false;

			// FPS tracking
			var fps = 0;
			var lastTime = performance.now();
			var frameCount = 0;

			// Performance profiling
			var performanceStats = {
				physics: { total: 0, count: 0, max: 0 },
				playerUpdate: { total: 0, count: 0, max: 0 },
				buildChunks: { total: 0, count: 0, max: 0 },
				updateChunks: { total: 0, count: 0, max: 0 },
				setCamera: { total: 0, count: 0, max: 0 },
				draw: { total: 0, count: 0, max: 0 },
				total: { total: 0, count: 0, max: 0 }
			};

			function measureTime(statName, fn) {
				var start = performance.now();
				var result = fn();
				var elapsed = performance.now() - start;
				var stat = performanceStats[statName];
				if (stat) {
					stat.total += elapsed;
					stat.count++;
					if (elapsed > stat.max) stat.max = elapsed;
				}
				return result;
			}

			// Make performance stats available globally for debugging
			window.performanceStats = performanceStats;

			function logPerformanceStats() {
				if (performanceStats.total.count === 0) return;
				console.log("=== Performance Stats (last second) ===");
				for (var key in performanceStats) {
					var stat = performanceStats[key];
					if (stat.count > 0) {
						var avg = stat.total / stat.count;
						console.log(key + ": avg=" + avg.toFixed(2) + "ms, max=" + stat.max.toFixed(2) + "ms, calls=" + stat.count);
					}
				}
				// Reset stats
				for (var key in performanceStats) {
					performanceStats[key] = { total: 0, count: 0, max: 0 };
				}
			}

			var pauseRenderDistanceSlider = document.getElementById('pauseRenderDistanceSlider');
			var pauseRenderDistanceValue = document.getElementById('pauseRenderDistanceValue');
			var pauseFpsToggle = document.getElementById('pauseFpsToggle');

			initGame();

			async function initGame() {
				try {
					var seedName = localStorage.getItem( SEED_SELECTION_KEY ) || DEFAULT_SEED_NAME;
					var seedDefinition = await fetchSeedDefinition( seedName );
					world = buildWorldFromSeed( seedDefinition, seedName );
					localStorage.setItem( SEED_SELECTION_KEY, seedName );
				} catch ( error ) {
					console.warn( "Fallo la carga de la seed remota, se usará un mundo plano local.", error );
					world = buildFallbackWorld();
				}

				setupGameSystems();
				initialisePauseSettings();
				startGameLoop();
			}

			function fetchSeedDefinition( seedName ) {
				return fetch( SEED_API_ENDPOINT + "?name=" + encodeURIComponent( seedName ), { cache: "no-store" } )
					.then( function( response ) {
						if ( !response.ok ) {
							throw new Error( "Seed API devolvió " + response.status );
						}
						return response.json();
					} );
			}

			function buildWorldFromSeed( seedDefinition, seedName ) {
				var sx = seedDefinition.sx || 255;
				var sy = seedDefinition.sy || 255;
				var sz = seedDefinition.sz || 255;
				var chunkSize = seedDefinition.chunkSize || 8;
				var chunkSizeY = 256; // Chunks de 8x8x256 (X, Z, Y) para optimizar aire - Y es vertical (altura)
				var w = new World( sx, sy, sz );
				if ( w.setChunking ) w.setChunking( chunkSize, chunkSizeY );

				if ( Array.isArray( seedDefinition.chunks ) && seedDefinition.chunks.length ) {
					preloadSeedChunks( w, seedDefinition.chunks, seedName );
				} else if ( typeof seedDefinition.blocks === "string" && seedDefinition.blocks.length ) {
					w.createFromString( seedDefinition.blocks );
				} else if ( typeof seedDefinition.height === "number" ) {
					w.createFlatWorld( seedDefinition.height );
				} else {
					w.createFlatWorld( 256 );
				}

				var spawn = seedDefinition.spawn || [ sx / 2 + 0.5, sy / 2 + 0.5, 64 ];
				w.spawn = new Vector( spawn[0], spawn[1], spawn[2] );
				return w;
			}

			function preloadSeedChunks( worldInstance, chunks, seedName ) {
				if ( typeof localStorage === "undefined" ) return;

				var previousSeed = localStorage.getItem( ACTIVE_SEED_KEY );
				if ( previousSeed !== seedName ) {
					clearStoredChunkCache( worldInstance.chunkStoragePrefix );
				}

				for ( var i = 0; i < chunks.length; i++ ) {
					var chunkDef = chunks[i];
					if ( typeof chunkDef.data !== "string" ) continue;
					var key = chunkDef.cx + "|" + chunkDef.cy + "|" + chunkDef.cz;
					try {
						localStorage.setItem( worldInstance.chunkStoragePrefix + key, chunkDef.data );
						if ( worldInstance.chunkStates ) worldInstance.chunkStates[key] = "stored";
					} catch ( e ) {
						console.warn( "No se pudo guardar el chunk " + key + " en localStorage.", e );
						break;
					}
				}

				localStorage.setItem( ACTIVE_SEED_KEY, seedName );
			}

			function clearStoredChunkCache( prefix ) {
				if ( typeof localStorage === "undefined" ) return;
				var keysToDelete = [];
				for ( var i = 0; i < localStorage.length; i++ ) {
					var key = localStorage.key( i );
					if ( key && key.indexOf( prefix ) === 0 ) keysToDelete.push( key );
				}
				for ( var k = 0; k < keysToDelete.length; k++ ) {
					localStorage.removeItem( keysToDelete[k] );
				}
			}

			function buildFallbackWorld() {
				var fallbackWorld = new World( 128, 128, 128 );
				fallbackWorld.createFlatWorld( 4 );
				return fallbackWorld;
			}

			function setupGameSystems() {
				render = new Renderer( "renderSurface" );
				render.setWorld( world, 8, 256 ); // Chunks de 8x8x256 para optimizar aire
				render.setPerspective( 60, 0.01, 200 );

				physics = new Physics();
				physics.setWorld( world );

				player = new Player();
				player.setWorld( world );
				player.setPhysics( physics );
				player.setInputCanvas( "renderSurface" );
				player.setMaterialSelector( "materialSelector" );
				
				// Setup debug key handlers
				setupDebugKeys();
			}
			
			function setupDebugKeys() {
				// Interceptar eventos de teclado para F3, C+F3 y F4 (modo espectador)
				var originalOnKeyEvent = player.onKeyEvent;
				player.onKeyEvent = function(keyCode, down) {
					// Llamar al handler original
					originalOnKeyEvent.call(this, keyCode, down);
					
					// F3 key code = 114
					if (keyCode === 114) {
						if (down) {
							// Verificar si C está presionado
							if (this.keys['c'] || this.keys[67]) {
								debugChunksEnabled = !debugChunksEnabled;
								render.showChunkGrid = debugChunksEnabled;
							} else {
								debugEnabled = !debugEnabled;
								document.getElementById('debugOverlay').style.display = debugEnabled ? 'block' : 'none';
							}
						}
					}
					
					// F4 key code = 115 (Modo espectador)
					if (keyCode === 115 && down) {
						if (this.spectatorMode !== undefined) {
							this.spectatorMode = !this.spectatorMode;
							// Resetear velocidad al cambiar de modo
							this.velocity = new Vector( 0, 0, 0 );
							this.falling = false;
							console.log('Modo espectador: ' + (this.spectatorMode ? 'ACTIVADO' : 'DESACTIVADO'));
						}
					}
				};
			}

			function initialisePauseSettings() {
				var savedRenderDistance = localStorage.getItem('renderDistance') || '8';
				pauseRenderDistanceSlider.value = savedRenderDistance;
				pauseRenderDistanceValue.textContent = savedRenderDistance;
				render.setRenderDistance(parseInt(savedRenderDistance));

				var savedShowFPS = localStorage.getItem('showFPS') || 'false';
				pauseFpsToggle.checked = savedShowFPS === 'true';
				if (savedShowFPS === 'true') {
					document.getElementById('fpsDisplay').style.display = 'block';
				}
			}

			// Function to start the render loop
			function startGameLoop() {
				gameLoopInterval = setInterval( function()
				{
					if (!paused) {
						var frameStart = performance.now();
						var time = new Date().getTime() / 1000.0;

						// Simulate physics
						measureTime('physics', function() {
							physics.simulate();
						});

						// Update local player
						measureTime('playerUpdate', function() {
							player.update();
						});

						// Build a chunk
						measureTime('buildChunks', function() {
							render.buildChunks( 8 );
						});

						// Draw world
						measureTime('setCamera', function() {
							render.setCamera( player.getEyePos().toArray(), player.angles );
						});

						measureTime('draw', function() {
							render.draw();
							// Also capture updateChunks time if available
							if (render._updateChunksStats && render._updateChunksStats.count > 0) {
								var stat = render._updateChunksStats;
								var avg = stat.total / stat.count;
								if (!performanceStats.updateChunks) {
									performanceStats.updateChunks = { total: 0, count: 0, max: 0 };
								}
								performanceStats.updateChunks.total += avg * stat.count;
								performanceStats.updateChunks.count += stat.count;
								if (stat.max > performanceStats.updateChunks.max) {
									performanceStats.updateChunks.max = stat.max;
								}
								// Reset renderer stats
								render._updateChunksStats = { total: 0, count: 0, max: 0 };
							}
						});
						
						// Update debug overlay
						if (debugEnabled) {
							updateDebugOverlay();
						}

						var frameTime = performance.now() - frameStart;
						measureTime('total', function() { return frameTime; });

						// Calculate FPS
						var currentTime = performance.now();
						frameCount++;
						if (currentTime - lastTime >= 1000) {
							fps = frameCount;
							frameCount = 0;
							lastTime = currentTime;
							if (document.getElementById('fpsDisplay').style.display !== 'none') {
								document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
							}
							// Log performance stats every second
							logPerformanceStats();
						}

						while ( new Date().getTime() / 1000 - time < 0.016 );
					}
				}, 1 );
			}

			// Update debug overlay with player information
			function updateDebugOverlay() {
				if (!player || !world) return;
				
				var pos = player.pos;
				var eyePos = player.getEyePos();
				var angles = player.angles;
				
				// Calcular bloque actual (donde está el jugador)
				// Ejes: X y Z = horizontal, Y = vertical (altura)
				var blockX = Math.floor(pos.x);
				var blockY = Math.floor(pos.y);
				var blockZ = Math.floor(pos.z);
				var block = world.getBlock(blockX, blockY, blockZ);
				
				// Intentar obtener el bloque que el jugador está mirando (usando pickAt)
				var lookedBlock = null;
				var lookedBlockX = blockX;
				var lookedBlockY = blockY;
				var lookedBlockZ = blockZ;
				if (render && render.pickAt) {
					var bPos = new Vector(blockX, blockY, blockZ);
					var centerX = render.canvas ? render.canvas.width / 2 : 0;
					var centerY = render.canvas ? render.canvas.height / 2 : 0;
					var pickedBlock = render.pickAt(
						new Vector(blockX - 4, Math.max(0, blockY - 2), blockZ - 4),
						new Vector(blockX + 4, Math.min(world.sy - 1, blockY + 2), blockZ + 4),
						centerX, centerY
					);
					if (pickedBlock && pickedBlock != false) {
						lookedBlock = world.getBlock(pickedBlock.x, pickedBlock.y, pickedBlock.z);
						lookedBlockX = pickedBlock.x;
						lookedBlockY = pickedBlock.y;
						lookedBlockZ = pickedBlock.z;
					}
				}
				
				// Usar el bloque que el jugador está mirando si está disponible, sino el bloque donde está parado
				var displayBlock = lookedBlock || block;
				var displayBlockX = lookedBlock ? lookedBlockX : blockX;
				var displayBlockY = lookedBlock ? lookedBlockY : blockY;
				var displayBlockZ = lookedBlock ? lookedBlockZ : blockZ;
				
				// Obtener nombre del bloque
				var blockName = 'AIR';
				if (displayBlock && displayBlock != BLOCK.AIR) {
					// Buscar el nombre del bloque comparando con los objetos BLOCK
					for (var key in BLOCK) {
						if (BLOCK[key] === displayBlock && typeof BLOCK[key] === 'object' && BLOCK[key].id !== undefined) {
							blockName = key;
							break;
						}
					}
					if (blockName === 'AIR') {
						blockName = 'UNKNOWN';
					}
				}
				
				// Calcular dirección (yaw en radianes, 0 = Norte, PI/2 = Este, PI = Sur, 3*PI/2 = Oeste)
				var yaw = angles[1];
				// Normalizar yaw a 0-2*PI
				while (yaw < 0) yaw += 2 * Math.PI;
				while (yaw >= 2 * Math.PI) yaw -= 2 * Math.PI;
				
				var direction = '';
				var yawDegrees = (yaw * 180 / Math.PI) % 360;
				if (yawDegrees < 0) yawDegrees += 360;
				
				// Determinar dirección cardinal
				if (yawDegrees >= 337.5 || yawDegrees < 22.5) direction = 'Norte';
				else if (yawDegrees >= 22.5 && yawDegrees < 67.5) direction = 'Noreste';
				else if (yawDegrees >= 67.5 && yawDegrees < 112.5) direction = 'Este';
				else if (yawDegrees >= 112.5 && yawDegrees < 157.5) direction = 'Sureste';
				else if (yawDegrees >= 157.5 && yawDegrees < 202.5) direction = 'Sur';
				else if (yawDegrees >= 202.5 && yawDegrees < 247.5) direction = 'Suroeste';
				else if (yawDegrees >= 247.5 && yawDegrees < 292.5) direction = 'Oeste';
				else if (yawDegrees >= 292.5 && yawDegrees < 337.5) direction = 'Noroeste';
				
				var debugHTML = '<div style="background: rgba(0,0,0,0.5); padding: 8px; border: 1px solid #00ff00;">';
				debugHTML += '<div><strong>Minecraft Web Edition - Debug (F3)</strong></div>';
				if (player.spectatorMode) {
					debugHTML += '<div style="color: #ffaa00; font-weight: bold; margin-top: 4px;">⚡ MODO ESPECTADOR (F4 para desactivar)</div>';
				}
				debugHTML += '<div style="margin-top: 8px;">';
				debugHTML += '<div>Posición: X: ' + pos.x.toFixed(2) + ' Y: ' + pos.y.toFixed(2) + ' Z: ' + pos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Ojos: X: ' + eyePos.x.toFixed(2) + ' Y: ' + eyePos.y.toFixed(2) + ' Z: ' + eyePos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Bloque: X: ' + displayBlockX + ' Y: ' + displayBlockY + ' Z: ' + displayBlockZ + ' (' + blockName + ')</div>';
				debugHTML += '<div>Dirección: ' + direction + ' (' + yawDegrees.toFixed(1) + '°)</div>';
				debugHTML += '<div>Pitch: ' + (angles[0] * 180 / Math.PI).toFixed(1) + '°</div>';
				
				// Información de chunks si C+F3 está activo
				if (debugChunksEnabled) {
					// Ejes: X y Z = horizontal, Y = vertical (altura)
					var chunkX = Math.floor(pos.x / render.chunkSize);
					var chunkZ = Math.floor(pos.z / render.chunkSize); // Z es horizontal
					var chunkY = 0; // Siempre 0 porque solo hay un chunk vertical (cubre toda la altura Y)
					
					debugHTML += '<div style="margin-top: 8px; border-top: 1px solid #00ff00; padding-top: 8px;">';
					debugHTML += '<div><strong>Chunk Info (C+F3)</strong></div>';
					debugHTML += '<div>Chunk actual: [' + chunkX + ', ' + chunkY + ', ' + chunkZ + ']</div>';
					debugHTML += '<div>Tamaño chunk: ' + render.chunkSize + 'x' + render.chunkSize + 'x' + render.chunkSizeY + ' (X, Z, Y)</div>';
					
					// Chunks alrededor
					debugHTML += '<div style="margin-top: 4px;">Chunks cargados: ';
					if (render.loadedChunks) {
						debugHTML += render.loadedChunks.size || 0;
					} else {
						debugHTML += '0';
					}
					debugHTML += '</div>';
					
					// Chunks cercanos
					debugHTML += '<div style="margin-top: 4px;">Chunks cercanos:</div>';
					var nearbyChunks = [];
					for (var dx = -1; dx <= 1; dx++) {
						for (var dy = -1; dy <= 1; dy++) {
							var cx = chunkX + dx;
							var cy = chunkY + dy;
							var cz = 0;
							var key = render.getChunkKey ? render.getChunkKey(cx, cy, cz) : (cx + '|' + cy + '|' + cz);
							var chunk = render.chunkLookup && render.chunkLookup[key];
							var loaded = chunk && chunk.loaded;
							nearbyChunks.push('[' + cx + ',' + cy + ',' + cz + ']' + (loaded ? '✓' : '✗'));
						}
					}
					debugHTML += '<div style="font-size: 10px;">' + nearbyChunks.join(' ') + '</div>';
					debugHTML += '</div>';
				}
				
				debugHTML += '</div>';
				debugHTML += '</div>';
				
				document.getElementById('debugInfo').innerHTML = debugHTML;
			}
			
			// Function to pause the game
			function pauseGame() {
				paused = true;
				document.getElementById('pauseOverlay').style.display = 'block';
				document.getElementById('pauseMenu').style.display = 'flex';
				document.getElementById('crosshair').style.display = 'none';
				document.getElementById('cursor').style.display = 'block';
				if ( player ) {
					player.pointerLocked = false;
					player.dragging = false;
					// Reset lastUpdate when pausing to prevent large delta on resume
					player.lastUpdate = new Date().getTime();
				}
			}

			// Function to resume the game
			function resumeGame() {
				paused = false;
				document.getElementById('pauseOverlay').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				if ( player && player.canvas ) {
					player.canvas.requestPointerLock();
				}
				// Reset FPS tracking when resuming
				lastTime = performance.now();
				frameCount = 0;
				
				// Reset player's lastUpdate to prevent large delta when resuming
				// This prevents the player from falling through the world
				if ( player && player.lastUpdate ) {
					player.lastUpdate = new Date().getTime();
				}
			}

			function playClickSound() { // detects when the player touches a button in the gui
                clickSound.currentTime = 0;
                clickSound.play().catch(function(e) { console.log('Audio play failed:', e); });
            }

			// Pause menu event handlers
			document.getElementById('resumeButton').onclick = function() {
				resumeGame();
			};

			document.getElementById('pauseSettingsButton').onclick = function() {
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'flex';
			};

			document.getElementById('exitButton').onclick = function() {
				window.location.href = 'index.html';
			};

			// Pause settings menu event handlers
			document.getElementById('pauseSettingsBackButton').onclick = function() {
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'flex';
			};

			pauseRenderDistanceSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseRenderDistanceValue.textContent = value;
				localStorage.setItem('renderDistance', value);
				if ( render ) render.setRenderDistance(value);
			};

			pauseFpsToggle.onchange = function() {
				localStorage.setItem('showFPS', pauseFpsToggle.checked);
				if (pauseFpsToggle.checked) {
					document.getElementById('fpsDisplay').style.display = 'block';
				} else {
					document.getElementById('fpsDisplay').style.display = 'none';
				}
			};
		</script>
	</body>
</html lang="es">
