<!DOCTYPE HTML>
<html lang="es">
	<head>
		<title>minecraft web edition 0.0.0-B</title>
		
		<!-- Character encoding -->
		<meta content="text/html" charset="UTF-8">
		<!-- Favicon -->
		<link rel="icon" href="media/gui/favicon.png">

		<!-- Stylesheet -->
		<link href="style/main.css" rel="stylesheet" type="text/css">
		
		<!-- Modules -->
		<script src="js/glMatrix-1.2.min.js" type="text/javascript"></script>
		<script src="js/blocks.js" type="text/javascript"></script>
		<script src="js/helpers.js" type="text/javascript"></script>
		<script src="js/items.js" type="text/javascript"></script>
		<script src="js/entities.js" type="text/javascript"></script>
		<script src="js/crafting.js" type="text/javascript"></script>
		<script src="js/worldManager.js" type="text/javascript"></script>
		<script src="js/world.js" type="text/javascript"></script>
		<script src="js/render.js" type="text/javascript"></script>
		<script src="js/physics.js" type="text/javascript"></script>
		<script src="js/player.js" type="text/javascript"></script>
	</head>
	
	<body oncontextmenu="return false">
		<!-- Loads the gui audio for buttons -->
		<audio id="clickSound" src="sounds/gui/Click_stereo.ogg.mp3" preload="auto"></audio>
		<!-- Render surface -->
		<canvas id="renderSurface"></canvas>

		<img id="cursor" class="cursor" src="media/gui/cursor.png" />
		<img id="crosshair" class="crosshair" src="media/gui/cursor.png" />

		<!-- FPS Display -->
		<div id="fpsDisplay" style="position: absolute; top: 10px; left: 10px; color: white; font-family: Minecraftia; display: none;"></div>

		<!-- Debug Overlay (F3) -->
		<div id="debugOverlay" style="position: absolute; top: 10px; left: 10px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 1000;">
			<div id="debugInfo"></div>
		</div>
		
		<!-- Mouse Debug Window (when inventory is open) -->
		<div id="mouseDebugWindow" style="position: absolute; top: 10px; right: 10px; color: #00ff00; font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.4; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); display: none; pointer-events: none; z-index: 1001; background: rgba(0,0,0,0.5); padding: 8px; border: 1px solid #00ff00;">
			<div><strong>Mouse Debug (Inventario)</strong></div>
			<div id="mouseDebugInfo"></div>
		</div>
		
		<!-- Item Title Display (shows item name when switching hotbar slots) -->
		<div id="itemTitleDisplay" style="position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%) scale(var(--gui-scale)); transform-origin: center bottom; color: white; font-family: 'Minecraftia', monospace; font-size: 11px; text-shadow: 2px 2px 0px rgba(0,0,0,0.8); pointer-events: none; z-index: 1002; opacity: 0; transition: opacity 0.3s ease-in-out; text-align: center;">
			<div id="itemTitleText"></div>
		</div>

		<!-- Dragged Item Cursor (follows mouse when dragging items) -->
		<div id="draggedItemCursor" style="position: fixed; pointer-events: none; z-index: 2000; display: none; image-rendering: pixelated;">
			<div id="draggedItemThumbnail" style="width: 32px; height: 32px;"></div>
			<div id="draggedItemCount" class="item-count" style="position: absolute; bottom: 0; right: 0; font-size: 12px;"></div>
		</div>

		<!-- Health Icons (Survival mode only) - Left side of hotbar -->
		<div id="healthIcons" class="health-icons" style="display: none;"></div>

		<!-- Hunger Icons (Survival mode only) - Right side of hotbar -->
		<div id="hungerIcons" class="hunger-icons" style="display: none;"></div>

		<!-- Creative Inventory Button (only visible in creative mode) -->
		<button id="creativeInventoryButton" class="creative-inventory-button" style="display: none;">
			<img src="media/item/chest.png" alt="Creative Inventory" />
		</button>

		<!-- Hotbar -->
		<div id="hotbar" class="hotbar">
			<div class="hotbar-slot" data-slot="0"></div>
			<div class="hotbar-slot" data-slot="1"></div>
			<div class="hotbar-slot" data-slot="2"></div>
			<div class="hotbar-slot" data-slot="3"></div>
			<div class="hotbar-slot" data-slot="4"></div>
			<div class="hotbar-slot" data-slot="5"></div>
			<div class="hotbar-slot" data-slot="6"></div>
			<div class="hotbar-slot" data-slot="7"></div>
			<div class="hotbar-slot" data-slot="8"></div>
		</div>

		<!-- Creative Inventory Menu -->
		<div id="creativeInventory" class="creative-inventory" style="display: none;">
			<div class="creative-inventory-overlay"></div>
			<div class="creative-inventory-container">
				<div class="creative-inventory-header">
					<h2>Inventario Creativo</h2>
					<button class="creative-inventory-close" id="creativeInventoryCloseButton">×</button>
				</div>
				<div id="creativeInventoryGrid" class="creative-inventory-grid">
					<!-- Blocks will be populated here -->
				</div>
			</div>
		</div>

		<!-- Inventory -->
		<div id="inventory" class="inventory" style="display: none;">
			<div id="inventoryOverlay" class="inventory-overlay"></div>
			<div class="inventory-container">
				<!-- Armor slots (top left) -->
				<div class="inventory-armor">
					<div class="inventory-slot armor-slot" data-type="helmet"></div>
					<div class="inventory-slot armor-slot" data-type="chestplate"></div>
					<div class="inventory-slot armor-slot" data-type="leggings"></div>
					<div class="inventory-slot armor-slot" data-type="boots"></div>
				</div>
				
				<!-- Player model area (left of armor) -->
				<div class="inventory-player-model">
					<canvas id="inventoryPlayerCanvas" class="inventory-player-canvas"></canvas>
				</div>
				
				<!-- Crafting grid 2x2 removed - only in crafting table GUI -->
				
				<!-- Main inventory grid (center) -->
				<div class="inventory-grid">
					<!-- 9 rows x 9 columns = 36 slots -->
				</div>
				
				<!-- Inventory hotbar (bottom) -->
				<div class="inventory-hotbar">
					<div class="inventory-slot" data-inv-slot="0"></div>
					<div class="inventory-slot" data-inv-slot="1"></div>
					<div class="inventory-slot" data-inv-slot="2"></div>
					<div class="inventory-slot" data-inv-slot="3"></div>
					<div class="inventory-slot" data-inv-slot="4"></div>
					<div class="inventory-slot" data-inv-slot="5"></div>
					<div class="inventory-slot" data-inv-slot="6"></div>
					<div class="inventory-slot" data-inv-slot="7"></div>
					<div class="inventory-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Crafting Table GUI -->
		<div id="craftingTable" class="crafting-table" style="display: none;">
			<div id="craftingTableOverlay" class="crafting-table-overlay"></div>
			<div class="crafting-table-container">
				<!-- Crafting grid 3x3 -->
				<div class="crafting-table-grid">
					<div class="crafting-table-slot" data-craft-table="0"></div>
					<div class="crafting-table-slot" data-craft-table="1"></div>
					<div class="crafting-table-slot" data-craft-table="2"></div>
					<div class="crafting-table-slot" data-craft-table="3"></div>
					<div class="crafting-table-slot" data-craft-table="4"></div>
					<div class="crafting-table-slot" data-craft-table="5"></div>
					<div class="crafting-table-slot" data-craft-table="6"></div>
					<div class="crafting-table-slot" data-craft-table="7"></div>
					<div class="crafting-table-slot" data-craft-table="8"></div>
				</div>
				
				<!-- Crafting arrow -->
				<div class="crafting-table-arrow"></div>
				
				<!-- Crafting output -->
				<div class="crafting-table-output">
					<div class="crafting-table-result" data-craft-table="output"></div>
				</div>
				
				<!-- Player inventory (below crafting area) -->
				<div class="crafting-table-inventory-grid">
					<!-- 3 rows x 9 columns -->
				</div>
				
				<!-- Hotbar (bottom) -->
				<div class="crafting-table-hotbar">
					<div class="crafting-table-slot" data-inv-slot="0"></div>
					<div class="crafting-table-slot" data-inv-slot="1"></div>
					<div class="crafting-table-slot" data-inv-slot="2"></div>
					<div class="crafting-table-slot" data-inv-slot="3"></div>
					<div class="crafting-table-slot" data-inv-slot="4"></div>
					<div class="crafting-table-slot" data-inv-slot="5"></div>
					<div class="crafting-table-slot" data-inv-slot="6"></div>
					<div class="crafting-table-slot" data-inv-slot="7"></div>
					<div class="crafting-table-slot" data-inv-slot="8"></div>
				</div>
			</div>
		</div>

		<!-- Pause overlay -->
		<div id="pauseOverlay" class="gui-overlay" style="display: none;"></div>

		<!-- World Selection Menu (shown before game starts) -->
		<div id="worldSelectionMenu" class="gui" style="display: flex;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Seleccionar Mundo</h2>
				</div>
				<div class="world-list-container">
					<div id="worldList" class="world-list">
						<!-- Worlds will be populated here -->
						<div class="world-empty">Cargando mundos...</div>
					</div>
				</div>
				<div class="world-selection-actions">
					<button id="createWorldButton" class="button">Crear Nuevo Mundo</button>
					<button id="refreshWorldsButton" class="button">Actualizar</button>
				</div>
			</div>
		</div>

		<!-- Create World Menu -->
		<div id="createWorldMenu" class="gui" style="display: none;">
			<div class="world-selection-container">
				<div class="world-selection-header">
					<h2 style="color: white; font-family: minecraftia; font-size: 24px; margin: 0 0 20px 0; text-shadow: 2px 2px 0px rgba(0,0,0,0.8);">Crear Nuevo Mundo</h2>
				</div>
				<div class="world-form">
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Nombre del Mundo:</label>
						<input type="text" id="worldNameInput" class="world-input" placeholder="Nuevo Mundo" maxlength="32" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Tamaño del Mundo:</label>
						<select id="worldSizeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="64">Pequeño (64x64x64)</option>
							<option value="128" selected>Mediano (128x128x128)</option>
							<option value="256">Grande (256x256x256)</option>
						</select>
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Altura del Terreno Plano:</label>
						<input type="number" id="flatHeightInput" class="world-input" value="4" min="1" max="64" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
					</div>
					<div class="form-field">
						<label style="color: white; font-family: minecraftia; font-size: 14px; display: block; margin-bottom: 5px;">Modo de Juego:</label>
						<select id="worldGameModeSelect" class="world-input" style="width: 100%; padding: 8px; font-family: minecraftia; font-size: 14px; background: rgba(0,0,0,0.5); border: 2px solid #555; color: white; box-sizing: border-box;">
							<option value="0" selected>Supervivencia</option>
							<option value="1">Creativo</option>
							<option value="2">Espectador</option>
						</select>
					</div>
					<div class="world-form-actions">
						<button id="createWorldConfirmButton" class="button">Crear Mundo</button>
						<button id="createWorldCancelButton" class="button">Cancelar</button>
					</div>
				</div>
			</div>
		</div>

		<!-- Pause menu -->
		<div id="pauseMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button id="resumeButton" class="button">Volver al juego</button>
				<button id="pauseSettingsButton" class="button">Ajustes</button>
				<button id="exitButton" class="button" details="guardar-y-salir">Salir al menu principal</button>
			</div>
		</div>

		<!-- Pause settings menu -->
		<div id="pauseSettingsMenu" class="gui" style="display: none;">
			<div class="mainmenu">
				<button class="button" id="pauseSettingsBackButton">Volver</button>
				<div style="margin: 20px 0;">
					<label for="pauseRenderDistanceSlider" style="color: white; font-family: Minecraftia;">Render Distance: <span id="pauseRenderDistanceValue">8</span> chunks</label><br>
					<input type="range" id="pauseRenderDistanceSlider" min="4" max="16" value="8" step="1" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label for="pauseGuiScaleSlider" style="color: white; font-family: Minecraftia;">GUI Scale: <span id="pauseGuiScaleValue">200</span>%</label><br>
					<input type="range" id="pauseGuiScaleSlider" min="100" max="200" value="200" step="10" style="width: 200px; margin-top: 10px;">
				</div>
				<div style="margin: 20px 0;">
					<label style="color: white; font-family: Minecraftia;">
						<input type="checkbox" id="pauseFpsToggle" style="margin-right: 10px;">Mostrar FPS
					</label>
				</div>
			</div>
		</div>
		
		<!-- Initialisation code -->
		<script type="text/javascript">
			
			const DEFAULT_SEED_NAME = "flat_default_seed";
			const SEED_API_ENDPOINT = "api/seeds.php";
			const ACTIVE_SEED_KEY = "activeSeedName";
			const SEED_SELECTION_KEY = "selectedSeed";

			var world;
			var render;
			var physics;
			var player;

			// Game state
			var paused = false;
			var gameLoopInterval;
			
			// Debug state
			var debugEnabled = false;
			var debugChunksEnabled = false;

			// FPS tracking
			var fps = 0;
			var lastTime = performance.now();
			var frameCount = 0;

			// Performance profiling
			var performanceStats = {
				physics: { total: 0, count: 0, max: 0 },
				playerUpdate: { total: 0, count: 0, max: 0 },
				buildChunks: { total: 0, count: 0, max: 0 },
				updateChunks: { total: 0, count: 0, max: 0 },
				setCamera: { total: 0, count: 0, max: 0 },
				draw: { total: 0, count: 0, max: 0 },
				total: { total: 0, count: 0, max: 0 }
			};

			function measureTime(statName, fn) {
				var start = performance.now();
				var result = fn();
				var elapsed = performance.now() - start;
				var stat = performanceStats[statName];
				if (stat) {
					stat.total += elapsed;
					stat.count++;
					if (elapsed > stat.max) stat.max = elapsed;
				}
				return result;
			}

			// Make performance stats available globally for debugging
			window.performanceStats = performanceStats;

			function logPerformanceStats() {
				if (performanceStats.total.count === 0) return;
				console.log("=== Performance Stats (last second) ===");
				for (var key in performanceStats) {
					var stat = performanceStats[key];
					if (stat.count > 0) {
						var avg = stat.total / stat.count;
						console.log(key + ": avg=" + avg.toFixed(2) + "ms, max=" + stat.max.toFixed(2) + "ms, calls=" + stat.count);
					}
				}
				// Reset stats
				for (var key in performanceStats) {
					performanceStats[key] = { total: 0, count: 0, max: 0 };
				}
			}

			var pauseRenderDistanceSlider = document.getElementById('pauseRenderDistanceSlider');
			var pauseRenderDistanceValue = document.getElementById('pauseRenderDistanceValue');
			var pauseGuiScaleSlider = document.getElementById('pauseGuiScaleSlider');
			var pauseGuiScaleValue = document.getElementById('pauseGuiScaleValue');
			var pauseFpsToggle = document.getElementById('pauseFpsToggle');

			// Initialize world manager and show selection menu
			initWorldManager();

			async function initWorldManager() {
				// Hide game canvas when showing world selection
				var canvas = document.getElementById("renderSurface");
				if ( canvas ) {
					canvas.style.display = "none";
				}
				
				// Initialize world manager
				try {
					await initializeWorldManager();
					await loadWorldsList();
					setupWorldManagerUI();
				} catch ( error ) {
					console.warn( "Failed to initialize world manager:", error );
					// Show error message
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar mundos. Usando mundo por defecto.</div>';
					}
				}
			}

			async function loadWorldsList() {
				try {
					var worlds = await getAllWorlds();
					var worldList = document.getElementById("worldList");
					if ( !worldList ) return;
					
					if ( worlds.length === 0 ) {
						worldList.innerHTML = '<div class="world-empty">No hay mundos. Crea uno nuevo para comenzar.</div>';
						return;
					}
					
					worldList.innerHTML = "";
					for ( var i = 0; i < worlds.length; i++ ) {
						var worldData = worlds[i];
						var worldItem = createWorldItem( worldData );
						worldList.appendChild( worldItem );
					}
				} catch ( error ) {
					console.error( "Failed to load worlds list:", error );
					var worldList = document.getElementById("worldList");
					if ( worldList ) {
						worldList.innerHTML = '<div class="world-empty">Error al cargar la lista de mundos.</div>';
					}
				}
			}

			function createWorldItem( worldData ) {
				var item = document.createElement("div");
				item.className = "world-item";
				item.setAttribute("data-world-id", worldData.id);
				
				var gameModeNames = { 0: "Supervivencia", 1: "Creativo", 2: "Espectador" };
				var gameModeName = gameModeNames[worldData.gameMode] || "Desconocido";
				
				var createdDate = new Date(worldData.created);
				var dateStr = createdDate.toLocaleDateString();
				
				item.innerHTML = '<div class="world-item-info">' +
					'<div class="world-item-name">' + escapeHtml(worldData.name) + '</div>' +
					'<div class="world-item-details">' + 
						gameModeName + ' | ' + 
						worldData.sizeX + 'x' + worldData.sizeY + 'x' + worldData.sizeZ + ' | ' +
						dateStr +
					'</div>' +
				'</div>' +
				'<div class="world-item-actions">' +
					'<button class="button-small" onclick="playWorld(' + worldData.id + ')">Jugar</button>' +
					'<button class="button-small" onclick="deleteWorld(' + worldData.id + ', this)">Eliminar</button>' +
				'</div>';
				
				// Click on item to play
				item.onclick = function(e) {
					if ( e.target.tagName !== "BUTTON" ) {
						playWorld( worldData.id );
					}
				};
				
				return item;
			}

			function escapeHtml(text) {
				var div = document.createElement("div");
				div.textContent = text;
				return div.innerHTML;
			}

			function setupWorldManagerUI() {
				// Create world button
				var createButton = document.getElementById("createWorldButton");
				if ( createButton ) {
					createButton.onclick = function() {
						document.getElementById("worldSelectionMenu").style.display = "none";
						document.getElementById("createWorldMenu").style.display = "flex";
					};
				}
				
				// Refresh worlds button
				var refreshButton = document.getElementById("refreshWorldsButton");
				if ( refreshButton ) {
					refreshButton.onclick = function() {
						loadWorldsList();
					};
				}
				
				// Create world form
				var createConfirmButton = document.getElementById("createWorldConfirmButton");
				if ( createConfirmButton ) {
					createConfirmButton.onclick = async function() {
						var name = document.getElementById("worldNameInput").value.trim() || "Nuevo Mundo";
						var size = parseInt(document.getElementById("worldSizeSelect").value) || 128;
						var flatHeight = parseInt(document.getElementById("flatHeightInput").value) || 4;
						var gameMode = parseInt(document.getElementById("worldGameModeSelect").value) || 0;
						
						try {
							var worldData = await createNewWorld( name, size, size, size, flatHeight, gameMode );
							
							// Crear instancia temporal del mundo para generar y guardar todos los chunks base
							var tempWorld = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
							tempWorld.worldId = worldData.id;
							tempWorld.flatHeight = worldData.flatHeight || 4;
							tempWorld.spawn = new Vector( worldData.spawn.x, worldData.spawn.y, worldData.spawn.z );
							
							// Generar y guardar todos los chunks base en IndexedDB
							console.log("Generating and saving all base chunks for new world...");
							await tempWorld.generateAndSaveAllChunks();
							console.log("World created and all chunks saved!");
							
							await loadWorldsList();
							document.getElementById("createWorldMenu").style.display = "none";
							document.getElementById("worldSelectionMenu").style.display = "flex";
							// Reset form
							document.getElementById("worldNameInput").value = "";
							document.getElementById("worldSizeSelect").value = "128";
							document.getElementById("flatHeightInput").value = "4";
							document.getElementById("worldGameModeSelect").value = "0";
						} catch ( error ) {
							console.error( "Failed to create world:", error );
							alert( "Error al crear el mundo: " + error.message );
						}
					};
				}
				
				var createCancelButton = document.getElementById("createWorldCancelButton");
				if ( createCancelButton ) {
					createCancelButton.onclick = function() {
						document.getElementById("createWorldMenu").style.display = "none";
						document.getElementById("worldSelectionMenu").style.display = "flex";
						// Reset form
						document.getElementById("worldNameInput").value = "";
						document.getElementById("worldSizeSelect").value = "128";
						document.getElementById("flatHeightInput").value = "4";
						document.getElementById("worldGameModeSelect").value = "0";
					};
				}
			}

			// Global functions for world actions
			window.playWorld = async function(worldId) {
				try {
					var worldData = await getWorldById(worldId);
					world = await loadWorldFromData(worldData);
					
					// Hide world selection menu
					document.getElementById("worldSelectionMenu").style.display = "none";
					document.getElementById("createWorldMenu").style.display = "none";
					
					// Show game canvas
					var canvas = document.getElementById("renderSurface");
					if ( canvas ) {
						canvas.style.display = "block";
					}
					
					// Start game
					setupGameSystems();
					initialisePauseSettings();
					
					// Load player data after player is created
					try {
						var playerData = await loadPlayerDataFromWorld(worldId);
						
						// If no data in IndexedDB, try localStorage backup
						if (!playerData) {
							var backupData = localStorage.getItem('player_backup_' + worldId);
							if (backupData) {
								try {
									playerData = JSON.parse(backupData);
									console.log("Loaded player data from backup");
									// Clear backup after loading
									localStorage.removeItem('player_backup_' + worldId);
								} catch (e) {
									console.warn("Could not parse backup player data:", e);
								}
							}
						}
						
						if (playerData && player) {
							player.loadPlayerData(playerData);
							console.log("Player data loaded successfully");
						}
					} catch (e) {
						console.warn("Could not load player data:", e);
					}
					
					startGameLoop();
				} catch ( error ) {
					console.error( "Failed to load world:", error );
					alert( "Error al cargar el mundo: " + error.message );
				}
			};

			window.deleteWorld = async function(worldId, buttonElement) {
				if ( !confirm( "¿Estás seguro de que quieres eliminar este mundo? Esta acción no se puede deshacer." ) ) {
					return;
				}
				
				try {
					await deleteWorldById(worldId);
					// Remove from list
					if ( buttonElement ) {
						var worldItem = buttonElement.closest(".world-item");
						if ( worldItem ) {
							worldItem.remove();
						}
					}
					// Reload list
					await loadWorldsList();
				} catch ( error ) {
					console.error( "Failed to delete world:", error );
					alert( "Error al eliminar el mundo: " + error.message );
				}
			};
			
			// loadWorldFromData( worldData )
			//
			// Loads a world from world metadata.
			
			async function loadWorldFromData( worldData ) {
				var w = new World( worldData.sizeX, worldData.sizeY, worldData.sizeZ );
				w.worldId = worldData.id;
				w.flatHeight = worldData.flatHeight || 4; // Store flatHeight for chunk generation
				w.gameMode = worldData.gameMode !== undefined ? worldData.gameMode : 0; // Store gameMode (default: Survival)
				
				// Set spawn position
				if ( worldData.spawn ) {
					w.spawn = new Vector( worldData.spawn.x, worldData.spawn.y, worldData.spawn.z );
				} else {
					w.spawn = new Vector( worldData.sizeX / 2 + 0.5, worldData.flatHeight + 1, worldData.sizeZ / 2 + 0.5 );
				}
				
				// Don't generate the entire world - chunks will be loaded on demand
				// This prevents loading everything into RAM
				
				return w;
			}

			function fetchSeedDefinition( seedName ) {
				return fetch( SEED_API_ENDPOINT + "?name=" + encodeURIComponent( seedName ), { cache: "no-store" } )
					.then( function( response ) {
						if ( !response.ok ) {
							throw new Error( "Seed API devolvió " + response.status );
						}
						return response.json();
					} );
			}

			function buildWorldFromSeed( seedDefinition, seedName ) { // this is an example of beta world, this should be removed
				var sx = seedDefinition.sx || 255;
				var sy = seedDefinition.sy || 255;
				var sz = seedDefinition.sz || 255;
				var chunkSize = seedDefinition.chunkSize || 8;
				var chunkSizeY = 256; // Chunks de 8x8x256 (X, Z, Y) para optimizar aire - Y es vertical (altura)
				var w = new World( sx, sy, sz );
				if ( w.setChunking ) w.setChunking( chunkSize, chunkSizeY );

				if ( Array.isArray( seedDefinition.chunks ) && seedDefinition.chunks.length ) {
					preloadSeedChunks( w, seedDefinition.chunks, seedName );
				} else if ( typeof seedDefinition.blocks === "string" && seedDefinition.blocks.length ) {
					w.createFromString( seedDefinition.blocks );
				} else if ( typeof seedDefinition.height === "number" ) {
					w.createFlatWorld( seedDefinition.height );
				} else {
					w.createFlatWorld( 256 );
				}

				var spawn = seedDefinition.spawn || [ sx / 2 + 0.5, sy / 2 + 0.5, 64 ];
				w.spawn = new Vector( spawn[0], spawn[1], spawn[2] );
				return w;
			}

			function preloadSeedChunks( worldInstance, chunks, seedName ) {
				if ( typeof localStorage === "undefined" ) return;

				var previousSeed = localStorage.getItem( ACTIVE_SEED_KEY );
				if ( previousSeed !== seedName ) {
					clearStoredChunkCache( worldInstance.chunkStoragePrefix );
				}

				for ( var i = 0; i < chunks.length; i++ ) {
					var chunkDef = chunks[i];
					if ( typeof chunkDef.data !== "string" ) continue;
					var key = chunkDef.cx + "|" + chunkDef.cy + "|" + chunkDef.cz;
					try {
						localStorage.setItem( worldInstance.chunkStoragePrefix + key, chunkDef.data );
						if ( worldInstance.chunkStates ) worldInstance.chunkStates[key] = "stored";
					} catch ( e ) {
						console.warn( "No se pudo guardar el chunk " + key + " en localStorage.", e );
						break;
					}
				}

				localStorage.setItem( ACTIVE_SEED_KEY, seedName );
			}

			function clearStoredChunkCache( prefix ) {
				if ( typeof localStorage === "undefined" ) return;
				var keysToDelete = [];
				for ( var i = 0; i < localStorage.length; i++ ) {
					var key = localStorage.key( i );
					if ( key && key.indexOf( prefix ) === 0 ) keysToDelete.push( key );
				}
				for ( var k = 0; k < keysToDelete.length; k++ ) {
					localStorage.removeItem( keysToDelete[k] );
				}
			}

			function buildFallbackWorld() {
				var fallbackWorld = new World( 128, 128, 128 );
				fallbackWorld.createFlatWorld( 4 );
				return fallbackWorld;
			}

			function setupGameSystems() {
				render = new Renderer( "renderSurface" );
				render.setWorld( world, 8, 256 ); // Chunks de 8x8x256 para optimizar aire
				render.setPerspective( 60, 0.01, 200 );

				physics = new Physics();
				physics.setWorld( world );
				// Agregar referencia a physics en el world para que el renderer pueda acceder
				world.physics = physics;

				player = new Player();
				player.setWorld( world );
				player.setPhysics( physics );
				player.setInputCanvas( "renderSurface" );
				player.initInventory();
				
				// Set game mode from world data
				if ( world.gameMode !== undefined ) {
					player.setGameMode( world.gameMode );
				}
				
				// Setup debug key handlers
				setupDebugKeys();
			}
			
			function setupDebugKeys() {
				// Interceptar eventos de teclado para F3, C+F3 y F4 (modo espectador)
				var originalOnKeyEvent = player.onKeyEvent;
				player.onKeyEvent = function(keyCode, down) {
					// Llamar al handler original
					originalOnKeyEvent.call(this, keyCode, down);
					
					// F3 key code = 114
					if (keyCode === 114) {
						if (down) {
							// Verificar si C está presionado
							if (this.keys['c'] || this.keys[67]) {
								debugChunksEnabled = !debugChunksEnabled;
								render.showChunkGrid = debugChunksEnabled;
							} else {
								debugEnabled = !debugEnabled;
								document.getElementById('debugOverlay').style.display = debugEnabled ? 'block' : 'none';
							}
						}
					}
					
					// F4 key code = 115 (Modo espectador)
					if (keyCode === 115 && down) {
						if (this.spectatorMode !== undefined) {
							this.spectatorMode = !this.spectatorMode;
							// Resetear velocidad al cambiar de modo
							this.velocity = new Vector( 0, 0, 0 );
							this.falling = false;
							// Forzar primera persona cuando se activa el modo espectador
							if (this.spectatorMode) {
								this.cameraMode = 1;
							}
							console.log('Modo espectador: ' + (this.spectatorMode ? 'ACTIVADO' : 'DESACTIVADO'));
						}
					}
					
					// F5 key code = 116 (Cambio de perspectiva) - manejado en player.js
				};
			}

			// Function to set GUI scale
			function setGuiScale(scale) {
				// scale is a percentage (100-300), convert to decimal (1.0-3.0)
				var scaleDecimal = scale / 100; // 100% = 1.0x, 200% = 2.0x, 300% = 3.0x
				document.documentElement.style.setProperty('--gui-scale', scaleDecimal);
				localStorage.setItem('guiScale', scale);
			}

			// Function to get GUI scale from localStorage or default
			function getGuiScale() {
				var savedScale = localStorage.getItem('guiScale');
				return savedScale ? parseInt(savedScale) : 200; // Default 200%
			}

			function initialisePauseSettings() {
				var savedRenderDistance = localStorage.getItem('renderDistance') || '8';
				pauseRenderDistanceSlider.value = savedRenderDistance;
				pauseRenderDistanceValue.textContent = savedRenderDistance;
				render.setRenderDistance(parseInt(savedRenderDistance));

				var savedGuiScale = getGuiScale();
				pauseGuiScaleSlider.value = savedGuiScale;
				pauseGuiScaleValue.textContent = savedGuiScale;
				setGuiScale(savedGuiScale);

				var savedShowFPS = localStorage.getItem('showFPS') || 'false';
				pauseFpsToggle.checked = savedShowFPS === 'true';
				if (savedShowFPS === 'true') {
					document.getElementById('fpsDisplay').style.display = 'block';
				}
			}

			// Setup Canvas 2D player model for inventory
			function setupInventoryPlayerModelCSS3D() {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) {
					// Try again after a short delay if element not ready
					setTimeout(setupInventoryPlayerModelCSS3D, 100);
					return;
				}
				
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Set canvas size - must match the black area size in inventory.png (54x54 base size)
				// The canvas must fit exactly inside the black area defined in the texture
				// GUI scale will scale it automatically, so we use base size
				canvas.width = 54;
				canvas.height = 54;
				
				var container = canvas.parentElement; // .inventory-player-model
				if (!container) return;
				
				// Prevent duplicate event listeners
				if (container._inventoryModelSetup) return;
				container._inventoryModelSetup = true;
				
				// Load player texture
				var playerImage = new Image();
				playerImage.onload = function() {
					// Store image for rendering
					canvas._playerTexture = playerImage;
					// Store ctx and canvas for later use
					canvas._ctx = ctx;
					// Initial render
					renderInventoryPlayerModel(ctx, canvas, 0, 0);
				};
				playerImage.src = 'media/player.png';
				
				// Rotation state (stored on canvas for persistence)
				// Use same system as player.js: angles and targetAngles with interpolation
				canvas._modelYaw = Math.PI; // Start facing forward (same as player.js default)
				canvas._modelPitch = 0;
				canvas._targetYaw = Math.PI;
				canvas._targetPitch = 0;
				
				// Make canvas and context accessible globally
				window._inventoryPlayerCanvas = canvas;
				window._inventoryPlayerCtx = ctx;
				
				// Global function to update model rotation (accessible from document listener)
				// Uses same logic as player.js onMouseMove: calculate target angles based on mouse position
				// Model follows mouse anywhere on screen, not just within canvas area
				window.updateInventoryPlayerModelRotation = function(e) {
					// Check if inventory is open
					var inventory = document.getElementById('inventory');
					if (!inventory || inventory.style.display !== 'flex') {
						return;
					}
					
					var canvas = window._inventoryPlayerCanvas;
					if (!canvas || !canvas._playerTexture || !canvas._ctx) {
						return; // Canvas or texture not ready
					}
					
					var container = canvas.parentElement;
					if (!container) return;
					
					// Get container bounds (accounting for GUI scale)
					var rect = container.getBoundingClientRect();
					
					// Calculate mouse position relative to container center
					var centerX = rect.left + rect.width / 2;
					var centerY = rect.top + rect.height / 2;
					
					// Calculate normalized position (-1 to 1, where 0,0 is center)
					// Use actual mouse position - model follows mouse anywhere
					var deltaX = e.clientX - centerX;
					var deltaY = e.clientY - centerY;
					
					// Normalize based on container size (similar to how Minecraft calculates)
					// In Minecraft vanilla, the model rotates based on mouse position relative to center
					// Use a sensitivity that makes the model rotate smoothly (similar to player.js)
					var sensitivity = rect.width / 3; // Sensitivity based on container size (bigger = less sensitive)
					var normalizedDeltaX = deltaX / sensitivity;
					var normalizedDeltaY = deltaY / sensitivity;
					
					// Ensure target angles are initialized
					if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
					if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
					
					// Update target angles (similar to player.js line 544-545)
					// In inventory, we want the model to look towards the mouse
					// For yaw: positive deltaX (mouse right) = rotate right (increase yaw)
					// For pitch: positive deltaY (mouse down) = look down (decrease pitch)
					canvas._targetYaw = Math.PI + normalizedDeltaX; // Base yaw is Math.PI (facing forward)
					canvas._targetPitch = -normalizedDeltaY; // Inverted: mouse down = look down
					
					// Clamp target pitch to prevent extreme angles
					if (canvas._targetPitch < -Math.PI/2) canvas._targetPitch = -Math.PI/2;
					if (canvas._targetPitch > Math.PI/2) canvas._targetPitch = Math.PI/2;
					
					// Store last mouse event for continuous tracking
					canvas._lastMouseEvent = e;
				};
				
				// Track mouse position constantly - store last position to maintain rotation
				// Store on canvas so it persists across function scopes
				canvas._lastMouseEvent = null;
				
				// Function to update mouse debug window
				function updateMouseDebug(e) {
					var debugWindow = document.getElementById('mouseDebugWindow');
					var debugInfo = document.getElementById('mouseDebugInfo');
					if (!debugWindow || !debugInfo) return;
					
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						var canvas = window._inventoryPlayerCanvas;
						if (canvas) {
							var container = canvas.parentElement;
							if (container) {
								var rect = container.getBoundingClientRect();
								var centerX = rect.left + rect.width / 2;
								var centerY = rect.top + rect.height / 2;
								
								// Mouse position relative to viewport
								var mouseX = e.clientX;
								var mouseY = e.clientY;
								
								// Mouse position relative to container
								var relativeX = mouseX - rect.left;
								var relativeY = mouseY - rect.top;
								
								// Mouse position relative to container center (normalized -1 to 1)
								var normalizedX = (mouseX - centerX) / (rect.width / 2);
								var normalizedY = (mouseY - centerY) / (rect.height / 2);
								
								// Rotation angles
								var yaw = canvas._modelYaw || 0;
								var pitch = canvas._modelPitch || 0;
								var yawDeg = (yaw * 180 / Math.PI).toFixed(1);
								var pitchDeg = (pitch * 180 / Math.PI).toFixed(1);
								
								// Is mouse inside model area?
								var insideModel = (mouseX >= rect.left && mouseX <= rect.right &&
								                  mouseY >= rect.top && mouseY <= rect.bottom);
								
								var html = '';
								html += '<div style="margin-top: 4px;">Mouse Viewport: ' + mouseX + ', ' + mouseY + '</div>';
								html += '<div>Container: [' + rect.left.toFixed(0) + ', ' + rect.top.toFixed(0) + '] ' + 
								        rect.width.toFixed(0) + 'x' + rect.height.toFixed(0) + '</div>';
								html += '<div>Rel. Container: ' + relativeX.toFixed(1) + ', ' + relativeY.toFixed(1) + '</div>';
								html += '<div>Normalized: ' + normalizedX.toFixed(3) + ', ' + normalizedY.toFixed(3) + '</div>';
								html += '<div style="margin-top: 4px; border-top: 1px solid #00ff00; padding-top: 4px;">';
								html += '<div>Yaw: ' + yawDeg + '° (' + yaw.toFixed(3) + ' rad)</div>';
								html += '<div>Pitch: ' + pitchDeg + '° (' + pitch.toFixed(3) + ' rad)</div>';
								html += '<div style="color: ' + (insideModel ? '#00ff00' : '#ffaa00') + ';">';
								html += 'Dentro área: ' + (insideModel ? 'Sí' : 'No');
								html += '</div></div>';
								
								debugInfo.innerHTML = html;
								debugWindow.style.display = 'block';
							}
						}
					} else {
						debugWindow.style.display = 'none';
					}
				}
				
				// Track mouse movement globally when inventory is open (exactly like player.js does)
				document.addEventListener('mousemove', function(e) {
					// Check if inventory is open
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						// Store last mouse event for continuous tracking (on canvas for persistence)
						var canvas = window._inventoryPlayerCanvas;
						if (canvas) {
							canvas._lastMouseEvent = e;
							// Update model rotation when mouse moves
							if (window.updateInventoryPlayerModelRotation) {
								window.updateInventoryPlayerModelRotation(e);
							}
							// Update debug window
							updateMouseDebug(e);
						}
					} else {
						// Hide debug window when inventory is closed
						var debugWindow = document.getElementById('mouseDebugWindow');
						if (debugWindow) {
							debugWindow.style.display = 'none';
						}
					}
				});
				
				// Continuously update rotation based on last known mouse position
				// This ensures the model keeps looking at the mouse even when it's not moving
				var mouseTrackingInterval = setInterval(function() {
					var inventory = document.getElementById('inventory');
					if (inventory && inventory.style.display === 'flex') {
						var canvas = window._inventoryPlayerCanvas;
						if (canvas && canvas._lastMouseEvent) {
							if (window.updateInventoryPlayerModelRotation) {
								window.updateInventoryPlayerModelRotation(canvas._lastMouseEvent);
							}
							// Update debug window continuously
							updateMouseDebug(canvas._lastMouseEvent);
						}
					}
				}, 16); // Update at ~60 FPS
				
				// Render loop for continuous updates when inventory is open
				// Uses same interpolation system as player.js (line 864-865)
				var renderLoop = null;
				var lastUpdateTime = Date.now();
				var startRenderLoop = function() {
					if (renderLoop) return; // Already running
					lastUpdateTime = Date.now();
					renderLoop = setInterval(function() {
						var inventory = document.getElementById('inventory');
						if (inventory && inventory.style.display === 'flex' && canvas._playerTexture && canvas._ctx) {
							// Interpolate angles towards target (same as player.js line 864-865)
							var now = Date.now();
							var delta = (now - lastUpdateTime) / 1000; // Convert to seconds
							lastUpdateTime = now;
							
							// Smooth interpolation (same factor as player.js: 30)
							var interpolationSpeed = 30;
							if (canvas._modelYaw === undefined) canvas._modelYaw = Math.PI;
							if (canvas._modelPitch === undefined) canvas._modelPitch = 0;
							if (canvas._targetYaw === undefined) canvas._targetYaw = Math.PI;
							if (canvas._targetPitch === undefined) canvas._targetPitch = 0;
							
							canvas._modelYaw += (canvas._targetYaw - canvas._modelYaw) * interpolationSpeed * delta;
							canvas._modelPitch += (canvas._targetPitch - canvas._modelPitch) * interpolationSpeed * delta;
							
							// Clamp pitch (same as player.js line 866-867)
							if (canvas._modelPitch < -Math.PI/2) canvas._modelPitch = -Math.PI/2;
							if (canvas._modelPitch > Math.PI/2) canvas._modelPitch = Math.PI/2;
							
							// Render with interpolated angles
							renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
						} else {
							// Stop loop if inventory closed
							if (renderLoop) {
								clearInterval(renderLoop);
								renderLoop = null;
							}
						}
					}, 16); // ~60 FPS - continuous rendering
				};
				
				// Start render loop when inventory opens
				var inventory = document.getElementById('inventory');
				if (inventory) {
					var observer = new MutationObserver(function(mutations) {
						for (var i = 0; i < mutations.length; i++) {
							var mutation = mutations[i];
							if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
								var display = inventory.style.display;
								if (display === 'flex' && canvas._playerTexture) {
									// Inventory opened, start render loop
									startRenderLoop();
									setTimeout(function() {
										if (canvas._ctx && canvas._playerTexture) {
											renderInventoryPlayerModel(canvas._ctx, canvas, canvas._modelYaw, canvas._modelPitch);
										}
										// Update debug window with initial mouse position if available
										if (canvas._lastMouseEvent) {
											updateMouseDebug(canvas._lastMouseEvent);
										}
									}, 10);
								} else if (display === 'none') {
									// Inventory closed, stop render loop and reset rotation
									if (renderLoop) {
										clearInterval(renderLoop);
										renderLoop = null;
									}
									// Reset to default angles (same as player.js: angles = [0, Math.PI, 0])
									canvas._modelYaw = Math.PI;
									canvas._modelPitch = 0;
									canvas._targetYaw = Math.PI;
									canvas._targetPitch = 0;
									// Hide debug window
									var debugWindow = document.getElementById('mouseDebugWindow');
									if (debugWindow) {
										debugWindow.style.display = 'none';
									}
								}
							}
						}
					});
					observer.observe(inventory, { attributes: true, attributeFilter: ['style'] });
				}
			}
			
			// Global function to render inventory player model (accessible from anywhere)
			window.renderInventoryPlayerModel = function(yaw, pitch) {
				var canvas = document.getElementById('inventoryPlayerCanvas');
				if (!canvas) return;
				var ctx = canvas.getContext('2d');
				if (!ctx) return;
				
				// Use stored rotation if not provided
				if (yaw === undefined) yaw = canvas._modelYaw || 0;
				if (pitch === undefined) pitch = canvas._modelPitch || 0;
				
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			};
			
			// Render the 3D player model using Canvas 2D (same rotation logic as render.js)
			// Model is centered in the canvas and rotates like the player in-game
			function renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch) {
				if (!canvas._playerTexture) {
					console.log('No texture loaded yet');
					return;
				}
				
				// Clear canvas with transparent background
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				ctx.imageSmoothingEnabled = false; // Pixelated rendering
				
				var img = canvas._playerTexture;
				var centerX = canvas.width / 2;
				var centerY = canvas.height / 2;
				// Calculate scale to fit model in 54x54px canvas (base size, before GUI scale)
				// Model dimensions at scale 1: head (8px) + body (12px) + legs (12px) = 32px height
				// Model width at scale 1: body (8px) + arms (4px each side) ≈ 16px
				// Canvas is 54px, so max scale for height: 54 / 32 ≈ 1.69
				// Canvas is 54px, so max scale for width: 54 / 16 ≈ 3.38
				// Use smaller scale (height constraint) with padding for rotation: 1.5
				var scale = 1.5; // Scale factor to fit model within 54x54px canvas with padding for rotation
				
				var bodyW = 8 * scale;
				var bodyH = 12 * scale;
				var headSize = 8 * scale;
				var armW = 4 * scale;
				var armH = 12 * scale;
				var legW = 4 * scale;
				var legH = 12 * scale;
				
				// Total model height (head + body + legs)
				var totalHeight = headSize + bodyH + legH;
				// Total model width (body + arms on each side)
				var totalWidth = bodyW + armW * 2;
				
				// Clamp pitch like in render.js (line 296-297)
				var clampedPitch = pitch;
				if (clampedPitch < -0.32) clampedPitch = -0.32;
				if (clampedPitch > 0.32) clampedPitch = 0.32;
				
				// Center the model in the canvas
				// Body center Y position: start from top of legs, go up by legH + bodyH/2
				var bodyCenterY = legH + bodyH/2;
				// Head center Y position: above body
				var headCenterY = legH + bodyH + headSize/2;
				// Total model center (vertical center of entire model)
				var modelCenterY = (legH + bodyH + headSize) / 2;
				
				// Offset to center the model in canvas
				var verticalOffset = centerY - modelCenterY;
				
				// Draw body first - rotates with yaw only (like render.js line 319-323)
				ctx.save();
				ctx.translate(centerX, verticalOffset + bodyCenterY);
				// Rotate body with yaw (same as render.js: Math.PI - player.angles[1])
				// Canvas rotates clockwise for positive values, so we need Math.PI - yaw
				ctx.rotate(Math.PI - yaw);
				
				// Draw body centered
				ctx.drawImage(img, 20, 20, 8, 12, -bodyW/2, -bodyH/2, bodyW, bodyH);
				
				// Draw arms attached to body
				ctx.drawImage(img, 44, 20, 4, 12, -bodyW/2 - armW + 2, -armH/2, armW, armH);
				ctx.drawImage(img, 44, 20, 4, 12, bodyW/2 - 2, -armH/2, armW, armH);
				
				// Draw legs (below body)
				ctx.drawImage(img, 4, 20, 4, 12, -bodyW/4 - legW/2, bodyH/2, legW, legH);
				ctx.drawImage(img, 4, 20, 4, 12, bodyW/4 - legW/2, bodyH/2, legW, legH);
				
				// Draw head with rotation (like render.js line 311-312)
				// Head rotates with both yaw and pitch
				// Head position: above body
				var headOffsetY = -bodyH/2 - headSize/2; // Offset from body center to head center
				
				ctx.save();
				// Move to head center position (above body)
				ctx.translate(0, headOffsetY);
				// Apply yaw rotation (same as body, but head can also pitch)
				// In render.js: Math.PI - player.angles[1]
				ctx.rotate(Math.PI - yaw);
				// Apply pitch rotation (like render.js: -pitch)
				// In canvas 2D, we simulate pitch by scaling vertically and adjusting position
				var pitchScale = Math.cos(-clampedPitch); // Scale down when looking up/down
				var pitchOffset = Math.sin(-clampedPitch) * headSize * 0.3; // Offset for perspective
				ctx.scale(1, pitchScale);
				ctx.translate(0, pitchOffset);
				
				// Draw head centered
				ctx.drawImage(img, 8, 8, 8, 8, -headSize/2, -headSize/2, headSize, headSize);
				ctx.restore();
				
				ctx.restore();
			}
			
			// Keep old function name for backward compatibility
			function renderInventoryPlayerModel(ctx, canvas, yaw, pitch) {
				renderInventoryPlayerModelInternal(ctx, canvas, yaw, pitch);
			}

			// Function to start the render loop
			function startGameLoop() {
				// Initialize CSS 3D player model rotation tracking
				setupInventoryPlayerModelCSS3D();
				
				gameLoopInterval = setInterval( function()
				{
					if (!paused) {
						var frameStart = performance.now();
						var time = new Date().getTime() / 1000.0;

						// Simulate physics
						measureTime('physics', function() {
							physics.simulate();
						});

						// Update animations (debe llamarse cada frame para animaciones suaves)
						if ( physics.updateAnimations ) {
							physics.updateAnimations();
							// Marcar chunks como dirty solo si contienen bloques animados
							if ( Object.keys( physics.fallingBlocks ).length > 0 ) {
								// Marcar solo los chunks que contienen bloques animados
								for ( var key in physics.fallingBlocks ) {
									var anim = physics.fallingBlocks[key];
									// Marcar el chunk que contiene este bloque animado
									render.onBlockChanged( anim.x, anim.startY, anim.z );
									// También marcar el chunk de destino si es diferente
									if ( anim.targetY != anim.startY ) {
										render.onBlockChanged( anim.x, anim.targetY, anim.z );
									}
								}
							}
						}

						// Update local player
						measureTime('playerUpdate', function() {
							player.update();
						});

						// Build a chunk
						measureTime('buildChunks', function() {
							render.buildChunks( 8 );
						});

						// Draw world
						measureTime('setCamera', function() {
							var eyePos = player.getEyePos();
							var cameraAngles = player.angles.slice(); // Copiar ángulos
							
							// Ajustar ángulos de la cámara según el modo de perspectiva
							// En modo espectador, solo usar primera persona (no ajustar ángulos)
							if ( !player.spectatorMode && player.cameraMode === 2 ) {
								// Segunda persona: cámara detrás del jugador, mirando hacia donde mira el jugador
								cameraAngles[0] = player.angles[0];
								cameraAngles[1] = player.angles[1];
							} else if ( !player.spectatorMode && player.cameraMode === 3 ) {
								// Tercera persona: cámara delante del jugador, conectada rígidamente a la cabeza
								// Si Steve baja la cabeza, la cámara también baja, pero la cámara mira hacia arriba
								// Calcular dirección desde la cámara hacia el jugador
								var playerEyePos = player.pos.add( new Vector( 0.0, 1.7, 0.0 ) );
								var dx = playerEyePos.x - eyePos.x;
								var dy = playerEyePos.y - eyePos.y;
								var dz = playerEyePos.z - eyePos.z;
								
								// Calcular pitch (ángulo vertical) hacia el jugador
								// Cuando el jugador mira hacia abajo (pitch negativo), la cámara debe mirar hacia arriba (pitch positivo)
								// Por lo tanto, invertimos el pitch calculado
								var horizontalDist = Math.sqrt(dx * dx + dz * dz);
								if (horizontalDist > 0.001) {
									cameraAngles[0] = Math.atan2(dy, horizontalDist); // Invertido: sin el negativo
								} else {
									cameraAngles[0] = 0; // Si está directamente arriba/abajo, no inclinar
								}
								
								// Calcular yaw (ángulo horizontal) hacia el jugador
								// En el sistema del juego, el movimiento usa: Math.cos(Math.PI/2 - yaw) para X y Math.sin(Math.PI/2 - yaw) para Z
								// Esto significa que yaw = 0 apunta hacia el norte (dirección positiva de Z)
								// Para calcular el yaw desde la cámara hacia el jugador:
								// - Necesitamos el ángulo que hace el vector (dx, dz) con el eje Z positivo
								// - Math.atan2(dx, dz) da el ángulo desde el eje Z hacia X
								// - Si dx=0 y dz>0 (norte), Math.atan2(0, 1) = 0, y queremos yaw = 0 ✓
								// - Si dx>0 y dz=0 (este), Math.atan2(1, 0) = PI/2, y queremos yaw = PI/2 ✓
								// - Por lo tanto, yaw = Math.atan2(dx, dz) es correcto
								if (horizontalDist > 0.001) {
									cameraAngles[1] = Math.atan2(dx, dz);
								} else {
									cameraAngles[1] = player.angles[1]; // Mantener el yaw del jugador si está directamente arriba/abajo
								}
							}
							
							render.setCamera( eyePos.toArray(), cameraAngles );
						});

						measureTime('draw', function() {
							render.draw();
							// Also capture updateChunks time if available
							if (render._updateChunksStats && render._updateChunksStats.count > 0) {
								var stat = render._updateChunksStats;
								var avg = stat.total / stat.count;
								if (!performanceStats.updateChunks) {
									performanceStats.updateChunks = { total: 0, count: 0, max: 0 };
								}
								performanceStats.updateChunks.total += avg * stat.count;
								performanceStats.updateChunks.count += stat.count;
								if (stat.max > performanceStats.updateChunks.max) {
									performanceStats.updateChunks.max = stat.max;
								}
								// Reset renderer stats
								render._updateChunksStats = { total: 0, count: 0, max: 0 };
							}
						});
						
						// Update debug overlay
						if (debugEnabled) {
							updateDebugOverlay();
						}

						var frameTime = performance.now() - frameStart;
						measureTime('total', function() { return frameTime; });

						// Calculate FPS
						var currentTime = performance.now();
						frameCount++;
						if (currentTime - lastTime >= 1000) {
							fps = frameCount;
							frameCount = 0;
							lastTime = currentTime;
							if (document.getElementById('fpsDisplay').style.display !== 'none') {
								document.getElementById('fpsDisplay').textContent = 'FPS: ' + fps;
							}
							// Log performance stats every second
							logPerformanceStats();
						}

						while ( new Date().getTime() / 1000 - time < 0.016 );
					}
				}, 1 );
			}

			// Update debug overlay with player information
			function updateDebugOverlay() {
				if (!player || !world) return;
				
				var pos = player.pos;
				var eyePos = player.getEyePos();
				var angles = player.angles;
				
				// Calcular bloque actual (donde está el jugador)
				// Ejes: X y Z = horizontal, Y = vertical (altura)
				var blockX = Math.floor(pos.x);
				var blockY = Math.floor(pos.y);
				var blockZ = Math.floor(pos.z);
				var block = world.getBlock(blockX, blockY, blockZ);
				
				// Intentar obtener el bloque que el jugador está mirando (usando pickAt)
				var lookedBlock = null;
				var lookedBlockX = blockX;
				var lookedBlockY = blockY;
				var lookedBlockZ = blockZ;
				if (render && render.pickAt) {
					var bPos = new Vector(blockX, blockY, blockZ);
					var centerX = render.canvas ? render.canvas.width / 2 : 0;
					var centerY = render.canvas ? render.canvas.height / 2 : 0;
					var pickedBlock = render.pickAt(
						new Vector(blockX - 4, Math.max(0, blockY - 2), blockZ - 4),
						new Vector(blockX + 4, Math.min(world.sy - 1, blockY + 2), blockZ + 4),
						centerX, centerY
					);
					if (pickedBlock && pickedBlock != false) {
						lookedBlock = world.getBlock(pickedBlock.x, pickedBlock.y, pickedBlock.z);
						lookedBlockX = pickedBlock.x;
						lookedBlockY = pickedBlock.y;
						lookedBlockZ = pickedBlock.z;
					}
				}
				
				// Usar el bloque que el jugador está mirando si está disponible, sino el bloque donde está parado
				var displayBlock = lookedBlock || block;
				var displayBlockX = lookedBlock ? lookedBlockX : blockX;
				var displayBlockY = lookedBlock ? lookedBlockY : blockY;
				var displayBlockZ = lookedBlock ? lookedBlockZ : blockZ;
				
				// Obtener nombre del bloque
				var blockName = 'AIR';
				if (displayBlock && displayBlock != BLOCK.AIR) {
					// Buscar el nombre del bloque comparando con los objetos BLOCK
					for (var key in BLOCK) {
						if (BLOCK[key] === displayBlock && typeof BLOCK[key] === 'object' && BLOCK[key].id !== undefined) {
							blockName = key;
							break;
						}
					}
					if (blockName === 'AIR') {
						blockName = 'UNKNOWN';
					}
				}
				
				// Calcular dirección (yaw en radianes, 0 = Norte, PI/2 = Este, PI = Sur, 3*PI/2 = Oeste)
				var yaw = angles[1];
				// Normalizar yaw a 0-2*PI
				while (yaw < 0) yaw += 2 * Math.PI;
				while (yaw >= 2 * Math.PI) yaw -= 2 * Math.PI;
				
				var direction = '';
				var yawDegrees = (yaw * 180 / Math.PI) % 360;
				if (yawDegrees < 0) yawDegrees += 360;
				
				// Determinar dirección cardinal
				if (yawDegrees >= 337.5 || yawDegrees < 22.5) direction = 'Norte';
				else if (yawDegrees >= 22.5 && yawDegrees < 67.5) direction = 'Noreste';
				else if (yawDegrees >= 67.5 && yawDegrees < 112.5) direction = 'Este';
				else if (yawDegrees >= 112.5 && yawDegrees < 157.5) direction = 'Sureste';
				else if (yawDegrees >= 157.5 && yawDegrees < 202.5) direction = 'Sur';
				else if (yawDegrees >= 202.5 && yawDegrees < 247.5) direction = 'Suroeste';
				else if (yawDegrees >= 247.5 && yawDegrees < 292.5) direction = 'Oeste';
				else if (yawDegrees >= 292.5 && yawDegrees < 337.5) direction = 'Noroeste';
				
				var debugHTML = '<div style="background: rgba(0,0,0,0.5); padding: 8px; border: 1px solid #00ff00;">';
				debugHTML += '<div><strong>Minecraft Web Edition - Debug (F3)</strong></div>';
				if (player.spectatorMode) {
					debugHTML += '<div style="color: #ffaa00; font-weight: bold; margin-top: 4px;">⚡ MODO ESPECTADOR (F4 para desactivar)</div>';
				}
				debugHTML += '<div style="margin-top: 8px;">';
				debugHTML += '<div>Posición: X: ' + pos.x.toFixed(2) + ' Y: ' + pos.y.toFixed(2) + ' Z: ' + pos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Ojos: X: ' + eyePos.x.toFixed(2) + ' Y: ' + eyePos.y.toFixed(2) + ' Z: ' + eyePos.z.toFixed(2) + '</div>';
				debugHTML += '<div>Bloque: X: ' + displayBlockX + ' Y: ' + displayBlockY + ' Z: ' + displayBlockZ + ' (' + blockName + ')</div>';
				debugHTML += '<div>Dirección: ' + direction + ' (' + yawDegrees.toFixed(1) + '°)</div>';
				debugHTML += '<div>Pitch: ' + (angles[0] * 180 / Math.PI).toFixed(1) + '°</div>';
				
				// Información de chunks si C+F3 está activo
				if (debugChunksEnabled) {
					// Ejes: X y Z = horizontal, Y = vertical (altura)
					var chunkX = Math.floor(pos.x / render.chunkSize);
					var chunkZ = Math.floor(pos.z / render.chunkSize); // Z es horizontal
					var chunkY = 0; // Siempre 0 porque solo hay un chunk vertical (cubre toda la altura Y)
					
					debugHTML += '<div style="margin-top: 8px; border-top: 1px solid #00ff00; padding-top: 8px;">';
					debugHTML += '<div><strong>Chunk Info (C+F3)</strong></div>';
					debugHTML += '<div>Chunk actual: [' + chunkX + ', ' + chunkY + ', ' + chunkZ + ']</div>';
					debugHTML += '<div>Tamaño chunk: ' + render.chunkSize + 'x' + render.chunkSize + 'x' + render.chunkSizeY + ' (X, Z, Y)</div>';
					
					// Chunks alrededor
					debugHTML += '<div style="margin-top: 4px;">Chunks cargados: ';
					if (render.loadedChunks) {
						debugHTML += render.loadedChunks.size || 0;
					} else {
						debugHTML += '0';
					}
					debugHTML += '</div>';
					
					// Chunks cercanos
					debugHTML += '<div style="margin-top: 4px;">Chunks cercanos:</div>';
					var nearbyChunks = [];
					for (var dx = -1; dx <= 1; dx++) {
						for (var dy = -1; dy <= 1; dy++) {
							var cx = chunkX + dx;
							var cy = chunkY + dy;
							var cz = 0;
							var key = render.getChunkKey ? render.getChunkKey(cx, cy, cz) : (cx + '|' + cy + '|' + cz);
							var chunk = render.chunkLookup && render.chunkLookup[key];
							var loaded = chunk && chunk.loaded;
							nearbyChunks.push('[' + cx + ',' + cy + ',' + cz + ']' + (loaded ? '✓' : '✗'));
						}
					}
					debugHTML += '<div style="font-size: 10px;">' + nearbyChunks.join(' ') + '</div>';
					debugHTML += '</div>';
				}
				
				debugHTML += '</div>';
				debugHTML += '</div>';
				
				document.getElementById('debugInfo').innerHTML = debugHTML;
			}
			
			// Function to pause the game
			function pauseGame() {
				paused = true;
				document.getElementById('pauseOverlay').style.display = 'block';
				document.getElementById('pauseMenu').style.display = 'flex';
				document.getElementById('crosshair').style.display = 'none';
				document.getElementById('cursor').style.display = 'block';
				if ( player ) {
					player.pointerLocked = false;
					player.dragging = false;
					// Reset lastUpdate when pausing to prevent large delta on resume
					player.lastUpdate = new Date().getTime();
				}
			}

			// Function to resume the game
			function resumeGame() {
				paused = false;
				document.getElementById('pauseOverlay').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				if ( player && player.canvas ) {
					player.canvas.requestPointerLock();
				}
				// Reset FPS tracking when resuming
				lastTime = performance.now();
				frameCount = 0;
				
				// Reset player's lastUpdate to prevent large delta when resuming
				// This prevents the player from falling through the world
				if ( player && player.lastUpdate ) {
					player.lastUpdate = new Date().getTime();
				}
			}

			function playClickSound() { // detects when the player touches a button in the gui
                clickSound.currentTime = 0;
                clickSound.play().catch(function(e) { console.log('Audio play failed:', e); });
            }

			// Pause menu event handlers
			document.getElementById('resumeButton').onclick = function() {
				resumeGame();
			};

			document.getElementById('pauseSettingsButton').onclick = function() {
				document.getElementById('pauseMenu').style.display = 'none';
				document.getElementById('pauseSettingsMenu').style.display = 'flex';
			};

			document.getElementById('exitButton').onclick = async function() {
				console.log("Saving game data before exit...");
				
				// Guardar todos los chunks modificados (esperar a que termine)
				if ( world && world.saveAllLoadedChunks ) {
					try {
						var savedChunks = await world.saveAllLoadedChunks();
						console.log("Saved", savedChunks, "modified chunks");
					} catch (e) {
						console.warn("Error saving chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Player data saved successfully");
					} catch (e) {
						console.warn("Could not save player data:", e);
					}
				}
				
				// Redirigir inmediatamente (los datos ya están guardados)
				window.location.href = 'index.html';
			};

			// Pause settings menu event handlers
			document.getElementById('pauseSettingsBackButton').onclick = function() {
				document.getElementById('pauseSettingsMenu').style.display = 'none';
				document.getElementById('pauseMenu').style.display = 'flex';
			};

			pauseRenderDistanceSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseRenderDistanceValue.textContent = value;
				localStorage.setItem('renderDistance', value);
				if ( render ) render.setRenderDistance(value);
			};

			pauseGuiScaleSlider.oninput = function() {
				var value = parseInt(this.value);
				pauseGuiScaleValue.textContent = value;
				setGuiScale(value);
			};

			pauseFpsToggle.onchange = function() {
				localStorage.setItem('showFPS', pauseFpsToggle.checked);
				if (pauseFpsToggle.checked) {
					document.getElementById('fpsDisplay').style.display = 'block';
				} else {
					document.getElementById('fpsDisplay').style.display = 'none';
				}
			};
			
			// Función para guardar todos los datos (chunks y jugador)
			async function saveAllGameData() {
				// Guardar chunks modificados
				if ( world && world.saveAllLoadedChunks ) {
					try {
						await world.saveAllLoadedChunks();
						console.log("Auto-saved chunks");
					} catch (e) {
						console.warn("Could not auto-save chunks:", e);
					}
				}
				
				// Guardar datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						await savePlayerDataToWorld(world.worldId, playerData);
						console.log("Auto-saved player data");
					} catch (e) {
						console.warn("Could not auto-save player data:", e);
					}
				}
			}
			
			// Auto-guardar datos del jugador cada 60 segundos (solo posición/inventario, NO chunks)
			// Los chunks se mantienen en RAM y solo se guardan al salir del mundo
			var autoSaveInterval = setInterval(function() {
				if ( !paused && world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
					} catch (e) {
						console.warn("Auto-save player data failed:", e);
					}
				}
			}, 60000);
			
			// Guardar chunks cuando se cierra la pestaña o el navegador
			window.addEventListener('beforeunload', function() {
				// Usar localStorage como backup rápido para datos del jugador
				if ( world && world.worldId && player ) {
					try {
						var playerData = player.serializePlayerData();
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Could not backup player data:", e);
					}
				}
				
				// Intentar guardar chunks (puede no completarse si se cierra muy rápido)
				if ( world && world.saveAllLoadedChunks ) {
					world.saveAllLoadedChunks();
				}
			});
			
			// Guardar cuando la pestaña se oculta (útil para móviles)
			document.addEventListener('visibilitychange', function() {
				if ( document.hidden && world && world.worldId && player ) {
					// Solo guardar datos del jugador (rápido)
					try {
						var playerData = player.serializePlayerData();
						savePlayerDataToWorld(world.worldId, playerData);
						localStorage.setItem('player_backup_' + world.worldId, JSON.stringify(playerData));
					} catch (e) {
						console.warn("Visibility save failed:", e);
					}
				}
			});
		</script>
	</body>
</html lang="es">
