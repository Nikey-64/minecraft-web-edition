// ==========================================
// World container
//
// This class contains the elements that make up the game world.
// Other modules retrieve information from the world or alter it
// using this class.
// ==========================================

// Constructor( sx, sy, sz )
//
// Creates a new world container with the specified world size.
// Up and down should always be aligned with the Z-direction.
//
// sx - World size in the X-direction.
// sy - World size in the Y-direction.
// sz - World size in the Z-direction.

function World( sx, sy, sz, chunkSize )
{
	this.sx = sx;
	this.sy = sy;
	this.sz = sz;
	
	// Chunk size (default 16x16x16 for optimal performance)
	this.chunkSize = chunkSize || 16;
	
	// Chunk storage: only loaded chunks are in memory
	// Key format: "chunk_x_y_z" where x, y, z are chunk coordinates
	this.loadedChunks = {};
	
	// Track which chunks are currently in memory (for memory management)
	this.chunksInMemory = {};
	this.maxChunksInMemory = clientInfo && clientInfo.isLowEnd ? 32 : 128;
	
	// World metadata for persistence
	this.metadata = {
		name: "New World",
		created: new Date().toISOString(),
		lastPlayed: new Date().toISOString(),
		version: "2.0", // Version 2.0 = chunk-based system
		chunkSize: this.chunkSize
	};
	
	// API endpoint for chunk generation
	this.chunkApiUrl = "js/recursos/world.php";
	
	// Cache for chunk loading promises (prevents duplicate requests)
	this.chunkLoadingPromises = {};
	
	// Statistics
	this.stats = {
		chunksLoaded: 0,
		chunksGenerated: 0,
		chunksFromCache: 0,
		chunksFromApi: 0
	};

	this.players = {};
}

// createFlatWorld()
//
// Sets up the world so that the bottom is filled with dirt,
// the top layer is grass, and above that is air.
// Now uses chunk-based system.

World.prototype.createFlatWorld = function( height )
{
	this.spawnPoint = new Vector( this.sx / 2 + 0.5, this.sy / 2 + 0.5, height + 1 );

	// Generate chunks on demand - this is just for compatibility
	// In practice, chunks will be generated by the API when needed
	// For now, we'll pre-generate spawn area chunks
	var spawnChunkCoords = this.getChunkCoords( this.spawnPoint.x, this.spawnPoint.y, this.spawnPoint.z );
	
	// Pre-generate a small area around spawn (3x3 chunks)
	for ( var dx = -1; dx <= 1; dx++ ) {
		for ( var dy = -1; dy <= 1; dy++ ) {
			for ( var dz = -1; dz <= 1; dz++ ) {
				var cx = spawnChunkCoords.cx + dx;
				var cy = spawnChunkCoords.cy + dy;
				var cz = spawnChunkCoords.cz + dz;
				
				// Generate flat world chunk
				this.generateFlatChunk( cx, cy, cz, height );
			}
		}
	}
}

// generateFlatChunk( cx, cy, cz, height )
//
// Generates a flat world chunk (for compatibility with old system).

World.prototype.generateFlatChunk = function( cx, cy, cz, height )
{
	var key = this.getChunkKey( cx, cy, cz );
	var startX = cx * this.chunkSize;
	var startY = cy * this.chunkSize;
	var startZ = cz * this.chunkSize;
	
	var actualSizeX = Math.min( this.chunkSize, this.sx - startX );
	var actualSizeY = Math.min( this.chunkSize, this.sy - startY );
	var actualSizeZ = Math.min( this.chunkSize, this.sz - startZ );
	
	var blocks = this.createEmptyChunk( actualSizeX, actualSizeY, actualSizeZ );
	
	for ( var x = 0; x < actualSizeX; x++ ) {
		for ( var y = 0; y < actualSizeY; y++ ) {
			for ( var z = 0; z < actualSizeZ; z++ ) {
				var worldZ = startZ + z;
				if ( worldZ < height - 1 ) {
					blocks[x][y][z] = BLOCK.DIRT;
				} else if ( worldZ == height - 1 ) {
					blocks[x][y][z] = BLOCK.GRASS;
				} else {
					blocks[x][y][z] = BLOCK.AIR;
				}
			}
		}
	}
	
	var chunk = {
		cx: cx,
		cy: cy,
		cz: cz,
		blocks: blocks,
		dirty: false,
		generated: true
	};
	
	this.loadedChunks[key] = chunk;
	this.chunksInMemory[key] = true;
	this.saveChunkToLocalStorage( chunk );
}

// createFromString( str )
//
// Creates a world from a string representation.
// This is the opposite of toNetworkString().
//
// NOTE: The world must have already been created
// with the appropriate size!

World.prototype.createFromString = function( str )
{
	var i = 0;
	
	for ( var x = 0; x < this.sx; x++ ) {
		for ( var y = 0; y < this.sy; y++ ) {
			for ( var z = 0; z < this.sz; z++ ) {
				this.blocks[x][y][z] = BLOCK.fromId( str.charCodeAt( i ) - 97 );
				i = i + 1;
			}
		}
	}
}

// getChunkKey( cx, cy, cz )
//
// Returns the storage key for a chunk at chunk coordinates.

World.prototype.getChunkKey = function( cx, cy, cz )
{
	return "chunk_" + cx + "_" + cy + "_" + cz;
}

// getChunkCoords( x, y, z )
//
// Converts world coordinates to chunk coordinates.

World.prototype.getChunkCoords = function( x, y, z )
{
	return {
		cx: Math.floor( x / this.chunkSize ),
		cy: Math.floor( y / this.chunkSize ),
		cz: Math.floor( z / this.chunkSize )
	};
}

// getLocalCoords( x, y, z )
//
// Converts world coordinates to local coordinates within a chunk.

World.prototype.getLocalCoords = function( x, y, z )
{
	var coords = this.getChunkCoords( x, y, z );
	return {
		lx: x - coords.cx * this.chunkSize,
		ly: y - coords.cy * this.chunkSize,
		lz: z - coords.cz * this.chunkSize
	};
}

// ensureChunkLoaded( cx, cy, cz )
//
// Ensures a chunk is loaded in memory. Returns a promise that resolves when the chunk is ready.

World.prototype.ensureChunkLoaded = function( cx, cy, cz )
{
	var key = this.getChunkKey( cx, cy, cz );
	
	// If already loaded, return immediately
	if ( this.loadedChunks[key] ) {
		return Promise.resolve( this.loadedChunks[key] );
	}
	
	// If already loading, return the existing promise
	if ( this.chunkLoadingPromises[key] ) {
		return this.chunkLoadingPromises[key];
	}
	
	// Start loading the chunk
	var promise = this.loadChunk( cx, cy, cz );
	this.chunkLoadingPromises[key] = promise;
	
	// Clean up promise cache when done
	promise.then( function() {
		delete this.chunkLoadingPromises[key];
	}.bind( this ) ).catch( function() {
		delete this.chunkLoadingPromises[key];
	}.bind( this ) );
	
	return promise;
}

// loadChunk( cx, cy, cz )
//
// Loads a chunk from localStorage or generates it from API.

World.prototype.loadChunk = function( cx, cy, cz )
{
	var key = this.getChunkKey( cx, cy, cz );
	var worldName = this.metadata.name;
	
	// Try to load from localStorage first
	var localStorageKey = 'minecraft_chunk_' + worldName + '_' + key;
	var chunkData = localStorage.getItem( localStorageKey );
	
	if ( chunkData ) {
		try {
			var chunkJson = JSON.parse( atob( chunkData ) );
			
			// Calculate actual chunk size
			var actualSizeX = Math.min( this.chunkSize, this.sx - cx * this.chunkSize );
			var actualSizeY = Math.min( this.chunkSize, this.sy - cy * this.chunkSize );
			var actualSizeZ = Math.min( this.chunkSize, this.sz - cz * this.chunkSize );
			
			var chunk = {
				cx: chunkJson.cx,
				cy: chunkJson.cy,
				cz: chunkJson.cz,
				blocks: this.chunkBlocksFromString( chunkJson.blocks, actualSizeX, actualSizeY, actualSizeZ ),
				dirty: chunkJson.dirty || false,
				generated: chunkJson.generated || false
			};
			
			this.loadedChunks[key] = chunk;
			this.chunksInMemory[key] = true;
			this.stats.chunksFromCache++;
			this.stats.chunksLoaded++;
			
			// Enforce memory limit
			this.enforceMemoryLimit();
			
			return Promise.resolve( chunk );
		} catch ( e ) {
			console.warn( 'Failed to parse chunk from localStorage:', e );
		}
	}
	
	// If not in localStorage, generate from API
	return this.generateChunkFromApi( cx, cy, cz );
}

// generateChunkFromApi( cx, cy, cz )
//
// Generates a chunk using the API endpoint.

World.prototype.generateChunkFromApi = function( cx, cy, cz )
{
	var key = this.getChunkKey( cx, cy, cz );
	var worldName = this.metadata.name;
	
	// Calculate world coordinates for chunk start
	var startX = cx * this.chunkSize;
	var startY = cy * this.chunkSize;
	var startZ = cz * this.chunkSize;
	
	// Calculate actual chunk size (may be smaller at world edges)
	var endX = Math.min( startX + this.chunkSize, this.sx );
	var endY = Math.min( startY + this.chunkSize, this.sy );
	var endZ = Math.min( startZ + this.chunkSize, this.sz );
	
	var actualSizeX = endX - startX;
	var actualSizeY = endY - startY;
	var actualSizeZ = endZ - startZ;
	
	return fetch( this.chunkApiUrl + '?action=generate&cx=' + cx + '&cy=' + cy + '&cz=' + cz + 
	              '&sx=' + actualSizeX + '&sy=' + actualSizeY + '&sz=' + actualSizeZ +
	              '&worldX=' + this.sx + '&worldY=' + this.sy + '&worldZ=' + this.sz )
		.then( function( response ) {
			if ( !response.ok ) {
				throw new Error( 'API request failed' );
			}
			return response.json();
		} )
		.then( function( data ) {
			if ( !data.success || !data.blocks ) {
				throw new Error( 'Invalid API response' );
			}
			
			// Parse blocks from string format
			var blocks = this.chunkBlocksFromString( data.blocks, actualSizeX, actualSizeY, actualSizeZ );
			
			// Create chunk object
			var chunk = {
				cx: cx,
				cy: cy,
				cz: cz,
				blocks: blocks,
				dirty: false,
				generated: true
			};
			
			// Store in memory
			this.loadedChunks[key] = chunk;
			this.chunksInMemory[key] = true;
			
			// Save to localStorage for future use
			this.saveChunkToLocalStorage( chunk );
			
			this.stats.chunksFromApi++;
			this.stats.chunksGenerated++;
			this.stats.chunksLoaded++;
			
			// Enforce memory limit
			this.enforceMemoryLimit();
			
			return chunk;
		}.bind( this ) )
		.catch( function( error ) {
			console.error( 'Failed to generate chunk from API:', error );
			// Fallback: create empty chunk
			var chunk = {
				cx: cx,
				cy: cy,
				cz: cz,
				blocks: this.createEmptyChunk( actualSizeX, actualSizeY, actualSizeZ ),
				dirty: false,
				generated: false
			};
			this.loadedChunks[key] = chunk;
			this.chunksInMemory[key] = true;
			return chunk;
		}.bind( this ) );
}

// createEmptyChunk( sx, sy, sz )
//
// Creates an empty chunk filled with air.

World.prototype.createEmptyChunk = function( sx, sy, sz )
{
	var blocks = [];
	for ( var x = 0; x < sx; x++ ) {
		blocks[x] = [];
		for ( var y = 0; y < sy; y++ ) {
			blocks[x][y] = [];
			for ( var z = 0; z < sz; z++ ) {
				blocks[x][y][z] = BLOCK.AIR;
			}
		}
	}
	return blocks;
}

// saveChunkToLocalStorage( chunk )
//
// Saves a chunk to localStorage.

World.prototype.saveChunkToLocalStorage = function( chunk )
{
	var key = this.getChunkKey( chunk.cx, chunk.cy, chunk.cz );
	var worldName = this.metadata.name;
	var localStorageKey = 'minecraft_chunk_' + worldName + '_' + key;
	
	try {
		// Convert blocks to string format for storage
		var blockString = this.chunkBlocksToString( chunk.blocks );
		
		var chunkData = {
			cx: chunk.cx,
			cy: chunk.cy,
			cz: chunk.cz,
			blocks: blockString,
			dirty: chunk.dirty,
			generated: chunk.generated || false,
			saved: new Date().toISOString()
		};
		
		// Compress and save
		var compressed = btoa( JSON.stringify( chunkData ) );
		localStorage.setItem( localStorageKey, compressed );
	} catch ( e ) {
		console.error( 'Failed to save chunk to localStorage:', e );
		// If storage is full, try to free space
		if ( e.name === 'QuotaExceededError' ) {
			this.freeStorageSpace();
		}
	}
}

// chunkBlocksToString( blocks )
//
// Converts chunk blocks array to string format.

World.prototype.chunkBlocksToString = function( blocks )
{
	var str = '';
	for ( var x = 0; x < blocks.length; x++ ) {
		for ( var y = 0; y < blocks[x].length; y++ ) {
			for ( var z = 0; z < blocks[x][y].length; z++ ) {
				var block = blocks[x][y][z];
				var blockId = block && block.id !== undefined ? block.id : 0;
				str += String.fromCharCode( 97 + blockId );
			}
		}
	}
	return str;
}

// chunkBlocksFromString( str, sx, sy, sz )
//
// Converts string format back to chunk blocks array.

World.prototype.chunkBlocksFromString = function( str, sx, sy, sz )
{
	var blocks = [];
	var i = 0;
	for ( var x = 0; x < sx; x++ ) {
		blocks[x] = [];
		for ( var y = 0; y < sy; y++ ) {
			blocks[x][y] = [];
			for ( var z = 0; z < sz; z++ ) {
				var blockId = str.charCodeAt( i ) - 97;
				blocks[x][y][z] = BLOCK.fromId( blockId );
				i++;
			}
		}
	}
	return blocks;
}

// enforceMemoryLimit()
//
// Unloads chunks that are far from active areas to stay within memory limits.

World.prototype.enforceMemoryLimit = function()
{
	var keys = Object.keys( this.chunksInMemory );
	if ( keys.length <= this.maxChunksInMemory ) {
		return;
	}
	
	// Find player position for distance calculation
	var playerPos = null;
	// Prefer localPlayer (singleplayer) if available
	if ( this.localPlayer && this.localPlayer.pos ) {
		playerPos = {
			x: this.localPlayer.pos.x,
			y: this.localPlayer.pos.y,
			z: this.localPlayer.pos.z
		};
	} else {
		// Fallback: any tracked player (multiplayer remote players)
		for ( var p in this.players ) {
			if ( this.players[p] && this.players[p].x !== undefined ) {
				playerPos = {
					x: this.players[p].x,
					y: this.players[p].y,
					z: this.players[p].z
				};
				break;
			}
		}
	}
	
	// If no player, unload oldest chunks
	if ( !playerPos ) {
		var toUnload = keys.slice( 0, keys.length - this.maxChunksInMemory );
		for ( var i = 0; i < toUnload.length; i++ ) {
			this.unloadChunk( toUnload[i] );
		}
		return;
	}
	
	// Sort chunks by distance from player
	var chunksWithDistance = [];
	for ( var i = 0; i < keys.length; i++ ) {
		var key = keys[i];
		var chunk = this.loadedChunks[key];
		if ( chunk ) {
			var chunkCenterX = ( chunk.cx + 0.5 ) * this.chunkSize;
			var chunkCenterY = ( chunk.cy + 0.5 ) * this.chunkSize;
			var chunkCenterZ = ( chunk.cz + 0.5 ) * this.chunkSize;
			
			var dx = chunkCenterX - playerPos.x;
			var dy = chunkCenterY - playerPos.y;
			var dz = chunkCenterZ - playerPos.z;
			var distanceSquared = dx * dx + dy * dy + dz * dz;
			
			chunksWithDistance.push( {
				key: key,
				distanceSquared: distanceSquared
			} );
		}
	}
	
	// Sort by distance (farthest first)
	chunksWithDistance.sort( function( a, b ) {
		return b.distanceSquared - a.distanceSquared;
	} );
	
	// Unload farthest chunks
	var toUnload = chunksWithDistance.slice( 0, keys.length - this.maxChunksInMemory );
	for ( var i = 0; i < toUnload.length; i++ ) {
		this.unloadChunk( toUnload[i].key );
	}
}

// unloadChunk( key )
//
// Unloads a chunk from memory, saving it first if dirty.

World.prototype.unloadChunk = function( key )
{
	var chunk = this.loadedChunks[key];
	if ( !chunk ) return;
	
	// Save chunk if dirty
	if ( chunk.dirty ) {
		this.saveChunkToLocalStorage( chunk );
		chunk.dirty = false;
	}
	
	// Remove from memory
	delete this.loadedChunks[key];
	delete this.chunksInMemory[key];
}

// freeStorageSpace()
//
// Frees up localStorage space by removing old chunks.

World.prototype.freeStorageSpace = function()
{
	var worldName = this.metadata.name;
	var keysToRemove = [];
	var totalSize = 0;
	
	// Collect all chunk keys with their sizes
	for ( var key in localStorage ) {
		if ( key.startsWith( 'minecraft_chunk_' + worldName + '_' ) ) {
			var data = localStorage.getItem( key );
			if ( data ) {
				keysToRemove.push( {
					key: key,
					size: data.length,
					timestamp: this.getChunkTimestamp( key )
				} );
				totalSize += data.length;
			}
		}
	}
	
	// Sort by timestamp (oldest first)
	keysToRemove.sort( function( a, b ) {
		return ( a.timestamp || 0 ) - ( b.timestamp || 0 );
	} );
	
	// Remove oldest chunks until we free up at least 1MB
	var freed = 0;
	var targetFree = 1024 * 1024; // 1MB
	for ( var i = 0; i < keysToRemove.length && freed < targetFree; i++ ) {
		var item = keysToRemove[i];
		// Don't remove chunks that are currently loaded
		var chunkKey = item.key.replace( 'minecraft_chunk_' + worldName + '_', '' );
		if ( !this.loadedChunks[chunkKey] ) {
			localStorage.removeItem( item.key );
			freed += item.size;
		}
	}
}

// getChunkTimestamp( key )
//
// Gets the timestamp when a chunk was saved.

World.prototype.getChunkTimestamp = function( key )
{
	try {
		var data = localStorage.getItem( key );
		if ( data ) {
			var chunkData = JSON.parse( atob( data ) );
			if ( chunkData.saved ) {
				return new Date( chunkData.saved ).getTime();
			}
		}
	} catch ( e ) {
		// Ignore errors
	}
	return 0;
}

// getBlock( x, y, z )
//
// Get the type of the block at the specified position.
// Now uses lazy-loading chunks.

World.prototype.getBlock = function( x, y, z )
{
	// Check bounds
	if ( x < 0 || y < 0 || z < 0 || x >= this.sx || y >= this.sy || z >= this.sz ) {
		return BLOCK.AIR;
	}
	
	// Get chunk coordinates
	var chunkCoords = this.getChunkCoords( x, y, z );
	var key = this.getChunkKey( chunkCoords.cx, chunkCoords.cy, chunkCoords.cz );
	
	// If chunk is loaded, get block from it
	if ( this.loadedChunks[key] ) {
		var local = this.getLocalCoords( x, y, z );
		var chunk = this.loadedChunks[key];
		if ( chunk.blocks && chunk.blocks[local.lx] && chunk.blocks[local.lx][local.ly] ) {
			return chunk.blocks[local.lx][local.ly][local.lz] || BLOCK.AIR;
		}
	}
	
	// Chunk not loaded - return AIR for now (will be loaded asynchronously)
	// This is a trade-off: we return AIR immediately instead of blocking
	return BLOCK.AIR;
}

// setBlock( x, y, z, type )
//
// Sets a block at the specified position.
// Now uses lazy-loading chunks.

World.prototype.setBlock = function( x, y, z, type )
{
	// Check bounds
	if ( x < 0 || y < 0 || z < 0 || x >= this.sx || y >= this.sy || z >= this.sz ) {
		return;
	}
	
	// Get chunk coordinates
	var chunkCoords = this.getChunkCoords( x, y, z );
	var key = this.getChunkKey( chunkCoords.cx, chunkCoords.cy, chunkCoords.cz );
	
	// Ensure chunk is loaded (synchronous for setBlock - may cause brief delay)
	if ( !this.loadedChunks[key] ) {
		// Load chunk synchronously (blocking) - this is necessary for setBlock
		// In a real implementation, you might want to queue block changes
		var chunk = this.loadChunkSync( chunkCoords.cx, chunkCoords.cy, chunkCoords.cz );
		if ( !chunk ) {
			console.warn( 'Failed to load chunk for setBlock at', x, y, z );
			return;
		}
	}
	
	// Set block in chunk
	var local = this.getLocalCoords( x, y, z );
	var chunk = this.loadedChunks[key];
	
	if ( !chunk.blocks ) {
		var actualSizeX = Math.min( this.chunkSize, this.sx - chunkCoords.cx * this.chunkSize );
		var actualSizeY = Math.min( this.chunkSize, this.sy - chunkCoords.cy * this.chunkSize );
		var actualSizeZ = Math.min( this.chunkSize, this.sz - chunkCoords.cz * this.chunkSize );
		chunk.blocks = this.createEmptyChunk( actualSizeX, actualSizeY, actualSizeZ );
	}
	
	if ( !chunk.blocks[local.lx] ) chunk.blocks[local.lx] = [];
	if ( !chunk.blocks[local.lx][local.ly] ) chunk.blocks[local.lx][local.ly] = [];
	
	chunk.blocks[local.lx][local.ly][local.lz] = type;
	chunk.dirty = true;
	
	// Notify renderer
	if ( this.renderer != null ) {
		this.renderer.onBlockChanged( x, y, z );
	}
}

// loadChunkSync( cx, cy, cz )
//
// Synchronously loads a chunk (blocking). Used when we need immediate access.

World.prototype.loadChunkSync = function( cx, cy, cz )
{
	var key = this.getChunkKey( cx, cy, cz );
	
	// If already loaded, return it
	if ( this.loadedChunks[key] ) {
		return this.loadedChunks[key];
	}
	
	// Try localStorage first (synchronous)
	var worldName = this.metadata.name;
	var localStorageKey = 'minecraft_chunk_' + worldName + '_' + key;
	var chunkData = localStorage.getItem( localStorageKey );
	
	if ( chunkData ) {
		try {
			var chunkJson = JSON.parse( atob( chunkData ) );
			
			// Calculate actual chunk size
			var actualSizeX = Math.min( this.chunkSize, this.sx - cx * this.chunkSize );
			var actualSizeY = Math.min( this.chunkSize, this.sy - cy * this.chunkSize );
			var actualSizeZ = Math.min( this.chunkSize, this.sz - cz * this.chunkSize );
			
			var chunk = {
				cx: chunkJson.cx,
				cy: chunkJson.cy,
				cz: chunkJson.cz,
				blocks: this.chunkBlocksFromString( chunkJson.blocks, actualSizeX, actualSizeY, actualSizeZ ),
				dirty: chunkJson.dirty || false,
				generated: chunkJson.generated || false
			};
			
			this.loadedChunks[key] = chunk;
			this.chunksInMemory[key] = true;
			this.stats.chunksFromCache++;
			this.stats.chunksLoaded++;
			
			this.enforceMemoryLimit();
			
			return chunk;
		} catch ( e ) {
			console.warn( 'Failed to parse chunk from localStorage:', e );
		}
	}
	
	// If not in localStorage, create empty chunk (will be generated asynchronously later)
	var actualSizeX = Math.min( this.chunkSize, this.sx - cx * this.chunkSize );
	var actualSizeY = Math.min( this.chunkSize, this.sy - cy * this.chunkSize );
	var actualSizeZ = Math.min( this.chunkSize, this.sz - cz * this.chunkSize );
	
	var chunk = {
		cx: cx,
		cy: cy,
		cz: cz,
		blocks: this.createEmptyChunk( actualSizeX, actualSizeY, actualSizeZ ),
		dirty: false,
		generated: false
	};
	
	this.loadedChunks[key] = chunk;
	this.chunksInMemory[key] = true;
	
	// Generate chunk asynchronously
	this.generateChunkFromApi( cx, cy, cz ).then( function( generatedChunk ) {
		// Update the chunk with generated data
		chunk.blocks = generatedChunk.blocks;
		chunk.generated = true;
		chunk.dirty = true;
		this.saveChunkToLocalStorage( chunk );
		if ( this.renderer ) {
			// Mark renderer chunks as dirty
			var renderChunks = this.renderer.chunks;
			if ( renderChunks ) {
				for ( var i = 0; i < renderChunks.length; i++ ) {
					var renderChunk = renderChunks[i];
					if ( renderChunk.start[0] <= cx * this.chunkSize && renderChunk.end[0] > cx * this.chunkSize &&
					     renderChunk.start[1] <= cy * this.chunkSize && renderChunk.end[1] > cy * this.chunkSize &&
					     renderChunk.start[2] <= cz * this.chunkSize && renderChunk.end[2] > cz * this.chunkSize ) {
						renderChunk.dirty = true;
					}
				}
			}
		}
	}.bind( this ) );
	
	return chunk;
}

// toNetworkString()
//
// Returns a string representation of this world.

World.prototype.toNetworkString = function()
{
	var blockArray = [];

	for ( var x = 0; x < this.sx; x++ )
		for ( var y = 0; y < this.sy; y++ )
			for ( var z = 0; z < this.sz; z++ )
				blockArray.push( String.fromCharCode( 97 + this.blocks[x][y][z].id ) );

	return blockArray.join( "" );
}

// saveToLocalStorage( worldName )
//
// Saves the world metadata to browser localStorage.
// Individual chunks are saved separately when they are modified.

World.prototype.saveToLocalStorage = function( worldName )
{
	try {
		// Update metadata
		this.metadata.name = worldName;
		this.metadata.lastPlayed = new Date().toISOString();

		// Save all dirty chunks first
		for ( var key in this.loadedChunks ) {
			var chunk = this.loadedChunks[key];
			if ( chunk.dirty ) {
				this.saveChunkToLocalStorage( chunk );
				chunk.dirty = false;
			}
		}

		// Prepare world metadata (chunks are stored separately)
		var worldData = {
			metadata: this.metadata,
			sx: this.sx,
			sy: this.sy,
			sz: this.sz,
			chunkSize: this.chunkSize,
			spawnPoint: this.spawnPoint ? {
				x: this.spawnPoint.x,
				y: this.spawnPoint.y,
				z: this.spawnPoint.z
			} : null
		};

		// Compress and save metadata
		var compressedData = btoa(JSON.stringify(worldData));
		localStorage.setItem('minecraft_world_' + worldName, compressedData);

		// Update world list
		this.updateWorldList(worldName);

		return true;
	} catch ( e ) {
		console.error('Failed to save world:', e);
		return false;
	}
}

// loadFromLocalStorage( worldName )
//
// Loads world metadata from browser localStorage.
// Chunks are loaded on-demand when needed.

World.prototype.loadFromLocalStorage = function( worldName )
{
	try {
		var compressedData = localStorage.getItem('minecraft_world_' + worldName);
		if (!compressedData) return false;

		var worldData = JSON.parse(atob(compressedData));

		// Validate data
		if (!worldData.sx || !worldData.sy || !worldData.sz) return false;

		// Set world dimensions
		this.sx = worldData.sx;
		this.sy = worldData.sy;
		this.sz = worldData.sz;
		
		// Set chunk size (for backwards compatibility)
		if ( worldData.chunkSize ) {
			this.chunkSize = worldData.chunkSize;
		}

		// Load metadata
		this.metadata = worldData.metadata || {
			name: worldName,
			created: new Date().toISOString(),
			lastPlayed: new Date().toISOString(),
			version: "2.0"
		};
		this.metadata.name = worldName;

		// Load spawn point
		if (worldData.spawnPoint) {
			this.spawnPoint = new Vector(
				worldData.spawnPoint.x,
				worldData.spawnPoint.y,
				worldData.spawnPoint.z
			);
		}

		// Chunks are loaded on-demand, not all at once
		// This is the key optimization for memory usage

		return true;
	} catch ( e ) {
		console.error('Failed to load world:', e);
		return false;
	}
}

// getSavedWorlds()
//
// Returns a list of all saved world names.

World.getSavedWorlds = function()
{
	var worlds = [];
	try {
		for (var key in localStorage) {
			if (key.startsWith('minecraft_world_')) {
				var worldName = key.replace('minecraft_world_', '');
				try {
					var compressedData = localStorage.getItem(key);
					if (compressedData) {
						var worldData = JSON.parse(atob(compressedData));
						if (worldData && worldData.metadata) {
							worlds.push({
								name: worldName,
								metadata: worldData.metadata
							});
						}
					}
				} catch (e) {
					console.warn('Invalid world data for:', worldName, e);
				}
			}
		}
	} catch (e) {
		console.error('Error accessing localStorage:', e);
		return [];
	}
	return worlds.sort(function(a, b) {
		return new Date(b.metadata.lastPlayed) - new Date(a.metadata.lastPlayed);
	});
}

// deleteWorld( worldName )
//
// Deletes a world from localStorage.

World.deleteWorld = function( worldName )
{
	try {
		localStorage.removeItem('minecraft_world_' + worldName);
		this.updateWorldList(worldName, true);
		return true;
	} catch ( e ) {
		console.error('Failed to delete world:', e);
		return false;
	}
}

// updateWorldList( worldName, remove )
//
// Updates the world list metadata in localStorage.

World.prototype.updateWorldList = function( worldName, remove )
{
	var worldListKey = 'minecraft_worlds_list';
	var worldList = JSON.parse(localStorage.getItem(worldListKey) || '[]');

	if (remove) {
		var index = worldList.indexOf(worldName);
		if (index > -1) {
			worldList.splice(index, 1);
		}
	} else if (worldList.indexOf(worldName) === -1) {
		worldList.push(worldName);
	}

	localStorage.setItem(worldListKey, JSON.stringify(worldList));
}

// exportWorld( worldName )
//
// Exports a world as a downloadable JSON file.

World.prototype.exportWorld = function( worldName )
{
	try {
		var compressedData = localStorage.getItem('minecraft_world_' + worldName);
		if (!compressedData) return false;

		var worldData = JSON.parse(atob(compressedData));

		// Create download
		var dataStr = JSON.stringify(worldData, null, 2);
		var dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

		var exportFileDefaultName = worldName + '.json';

		var linkElement = document.createElement('a');
		linkElement.setAttribute('href', dataUri);
		linkElement.setAttribute('download', exportFileDefaultName);
		linkElement.click();

		return true;
	} catch ( e ) {
		console.error('Failed to export world:', e);
		return false;
	}
}

// importWorld( file, callback )
//
// Imports a world from a JSON file.

World.importWorld = function( file, callback )
{
	var reader = new FileReader();
	reader.onload = function(e) {
		try {
			var worldData = JSON.parse(e.target.result);

			// Validate world data
			if (!worldData.sx || !worldData.sy || !worldData.sz || !worldData.blocks) {
				callback(false, 'Invalid world file format');
				return;
			}

			// Check world size limits
			var maxSize = 256;
			if (worldData.sx > maxSize || worldData.sy > maxSize || worldData.sz > maxSize) {
				callback(false, 'World too large (max ' + maxSize + 'x' + maxSize + 'x' + maxSize + ')');
				return;
			}

			// Generate unique name if needed
			var worldName = worldData.metadata ? worldData.metadata.name : 'Imported World';
			var counter = 1;
			var originalName = worldName;
			while (localStorage.getItem('minecraft_world_' + worldName)) {
				worldName = originalName + ' (' + counter + ')';
				counter++;
			}

			// Save imported world
			var compressedData = btoa(JSON.stringify(worldData));
			localStorage.setItem('minecraft_world_' + worldName, compressedData);

			callback(true, worldName);
		} catch ( e ) {
			callback(false, 'Failed to parse world file: ' + e.message);
		}
	};
	reader.readAsText(file);
}

// Export to node.js
if ( typeof( exports ) != "undefined" )
{
	// loadFromFile( filename )
	//
	// Load a world from a file previously saved with saveToFile().
	// The world must have already been allocated with the
	// appropriate dimensions.

	World.prototype.loadFromFile = function( filename )
	{
		var fs = require( "fs" );
		try {
			fs.lstatSync( filename );
			var data = fs.readFileSync( filename, "utf8" ).split( "," );
			this.createFromString( data[3] );
			this.spawnPoint = new Vector( parseInt( data[0] ), parseInt( data[1] ), parseInt( data[2] ) );
			return true;
		} catch ( e ) {
			return false;
		}
	}

	// saveToFile( filename )
	//
	// Saves a world and the spawn point to a file.
	// The world can be loaded from it afterwards with loadFromFile().

	World.prototype.saveToFile = function( filename )
	{
		var data = this.spawnPoint.x + "," + this.spawnPoint.y + "," + this.spawnPoint.z + "," + this.toNetworkString();
		require( "fs" ).writeFileSync( filename, data );
	}

	exports.World = World;
}
